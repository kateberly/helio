C STOPPED REPLACING CC WITH PRNTCON FOR OUTPUT CONTROL.
C
C
C PROGRAM Galileo
c ***  Version 5.7  March, 2013 *** runs on OS X jw
c Copyright 1974 - 2013
c Joseph Woelfel
c The Galileo Company
c 99 Larchmont Road
c Buffalo, NY 14214
c
c
c Scott Danielsen 2-23-90 made v54 PC compatible.
c
C         CONTROL CARD READ-IN AND JOB SET-UP
C
C RESERVE STORAGE
      IMPLICIT REAL (A-H,O-Z)
      INTEGER XDIM(40,40),DIM(40),OPT(30),NSTAR(40,40)
      DIMENSION V1(40),V2(40),V3(40),V4(40),V5(40)
      DIMENSION M1(40,40),M2(40,40),M3(40,40),M4(40,40),M5(40,40)
c      DIMENSION NAMES (5,2)
      CHARACTER*40 LABELS(40),run
      character*1 ess,blnk,period,zero,minus,ichr,in(76),two  !Feb 24, 2013 jw
c      INTEGER BLNK,ESS,PLT,PLTONL
      INTEGER EIG,ROT,RD
c      CHARACTER * 40 RUN
      character*4 mess ! feb 24, 2013
      character*80 ifile,rsfile,prtfile    ! 1/Feb/1988 - jw prtfie added 3/24/13 jw
      COMMON/BASE/MNS,EIG,ROT,RD
      COMMON/ASVAR/IVAR
      COMMON/LFN/LFNI,LFNO,LFNP
      COMMON/KJOB/KJOB
      COMMON/OPT/OPT
      COMMON/PLT/PLT
      COMMON/PLTONL/PLTONL
      COMMON/RUN/RUN
      REAL M1,M2,M3,M4,M5
      CHARACTER*1 IT(76)
      DATA BLNK/' '/
      DATA ESS/'s'/
      data lfno/66/  ! i found lfno to be zero everywhere, so here I define it... jw 3/3/13
c      DATA NAMES/'Joe ','Woel','fel',' ',' ',
c     +'Rick',' Hol','mes',' ',' '/
c      DATA NCNT/2/
c
c              MAIN PARAMETERS
c
c      call datwrt('Galileo_PC','V1.0')
		go to 401
402		print*,' Je suis desole, no runstream there...'
401      write(6,400)
 400  format(//////////////,' Where is your runstream?')
c      write(*,'(a,\)') ' ====>'
      read(5,222)rsfile
      
      if(rsfile.eq.'?')call help  ! added 11/25/13 jw
      if(rsfile.eq.'?')go to 401
      
      open(unit=55,file=rsfile,status='old',err=402)
c      print*, 'at line 54, lfno is  ', lfno ! ** debug
      lfni=55
      read(lfni,222)ifile   !PRINT FILE
  222 format(a80)
      OPEN(UNIT=LFNO,FILE=IFILE,STATUS='UNKNOWN')
      prtfile=ifile  ! ** debug jw 3/14/13
      call prntcon(15,lfno)
      read(lfni,222)ifile   !CRDS FILE
      open(unit=lfnp,file=ifile,status='unknown')
      READ(lfni,10)RUN
   10 FORMAT(15X,A40)
      call prntcon(12,lfno)
c    print*,' run name  ', run  ! ** debug
      WRITE(LFNO,405) RUN
  405 FORMAT (30X,' Galileo Ruby Anniversary Edition 5.7'//////////31X,
     +'Run Name is...................',A40)
      READ(LFNI,20) (IT(K),K=1,4)
   20 FORMAT(15X,4A1)
      CALL INTs(IT,1,4,MSIZE)
c      print*,' number of concepts is ', msize ! ** debug
      WRITE(LFNO,420) MSIZE
  420 FORMAT (' ',30X,'Number of concepts is.........',I3)
      READ(LFNI,20) (IT(K),K=1,4)
      CALL INTS(IT,1,4,NSETS)
c      print*,' nsets is ',nsets  ! ** debug
      WRITE(LFNO,430) NSETS
  430 FORMAT (' ',30X,'Number of sets of data is.....',I3)
C
      CALL CONCD(MSIZE,NSETS,XDIM,LABELS,NSTAR,DIM)
C
C SCRAMBLE RANDOMLY THE NAMES OF THE AUTHORS   (THIS IS A DEMOCRACY...)
C
C PRINT THE HEADER
      ICHR=BLNK
      IF(NSETS.GT.1)ICHR=ESS
      call prntcon(12,lfno)
       WRITE(LFNO,1000)
1000  FORMAT(/10X,'Galileo Version 5.7 ** Update March 2013 **',///
     +10X,' Copyright 1977 - 2013',//
     +(10X,5A4))
      write(lfno,23)
  23  format('Joseph Woelfel', // 'Richard A. Holmes',//,
     +'Scott Danielsen',//,'Rudolf Zelf')

      WRITE(LFNO,1001) RUN,MSIZE,NSETS,ICHR
1001  FORMAT(/10X,'This program is the exclusive '/
     +10X,'property of The Galileo Company               '/
     +,10X,'99 Larchmont Road                '/
     +10X,'Buffalo, NY 14214                       '/
     +10X,'Use of this program without written '/
     +10X,'authorization from The Galileo Company  '/
     +10X,'is strictly prohibited. '///
     +1X,'Galileo 5.7 March,2013'//1x,'Galileo is a trademark'/
     +' of The Galileo Co.'/' 99 Larchmont Road'/' Buffalo, NY 14214
     +',///
     +/////////45X,A40//50X,'An analysis of ',I2,' concepts'/
     +50X,'utilizing ',I3,' set',A1,' of data.')
C
C SET UP THE BASES FOR THE RANDOM FILE STRUCTURE
C
C      NAME      NUM      STARTS      RECURSIVE DEFF.      TYPE OF DATA
C       MNS    NSETS           0                 0       MEANS MATRICIES
C       EIG    NSETS       NSETS         MNS+NSETS     UNROTATED COORDS.
C       ROT  NSETS-1     2*NSETS         EIG+NSETS       ROTATED COORDS.
C        RD  UNKNOWN     3*NSETS       ROT+NSETS-1       RAW DATA CASES
C
      MNS=0
      EIG=MNS+NSETS
      ROT=EIG+NSETS
      RD=ROT+NSETS-1
c
c INITIALIZE THE RANDOM FILE
c
      OPEN(UNIT=8, ACCESS='DIRECT',FORM='UNFORMATTED',RECL=6400
     +,STATUS='scratch')!     SRD 3-23-90 ,associated variable=ivar)
c
c         CALLING ROUTINES
c
      GO TO (9000,9100,9200,9300,9400),  KJOB
9000     CALL MTRIX(MSIZE,NSETS,M1,M1,M2,M3,M4,M5,0)
      GO TO 929
C
9100  IF(OPT(1))9101,9102,9101
9101     CALL MTRIX(MSIZE,NSETS,M1,M1,M2,M3,M4,M5,1)
9102  CALL CNTEIG(MSIZE,NSETS,LABELS,NSTAR,DIM,M1,M2,M3,M4,XDIM,
     +V1,V2,V3,V4,V5,KJOB)
      GO TO 929
C
9200  IF(OPT(1))9201,9202,9201
9201  CALL MTRIX(MSIZE,NSETS,M1,M1,M2,M3,M4,M5,1)
      GO TO 9203
9202  IF(OPT(3))9204,9203,9204
9203  CALL CNTEIG(MSIZE,NSETS,LABELS,NSTAR,DIM,M1,M2,M3,M4,XDIM,
     +V1,V2,V3,V4,V5,KJOB)
9204  CALL ROTIT(MSIZE,NSETS,DIM,XDIM,M1,M2,M3,M4,V1,V2,LABELS,NSTAR)
      GO TO 929
C
9300  CONTINUE
      PLTONL=1
      PLT=0
c      CALL PLOTIT(MSIZE,NSETS,M1,M2,M3,M4,LABELS)
      GOTO 929
C
C   CALL THE A-M-G  ROUTINE
9400   CONTINUE
      CALL AMGONL(MSIZE,NSETS,M1,LABELS,V1,V2)
C
929   CONTINUE
C
C CALL PLOT ROUTINE FROM A NORMAL RUN
c      IF(PLT.NE.0)CALL PLOTIT(MSIZE,NSETS,M1,M2,M3,M4,LABELS)
C
C         TERMINATION
C
      WRITE(LFNO,1004) RUN
 1004 FORMAT (//50X,'End Program Galileo'/20x,'Ruby Anniversary Edition
     + --  Forty Years of Galileo Precision ',//46X,A40,5X,'PAU')
      print*,' Your output is at ',prtfile 
      print*,' Your coordinates are at ',ifile 
      print*,' Galileo Version 5.7 Ruby Anniversary Edition  '
      
      print*,' Pau  '
      write(*,1005)
 1005 format(/////)     
c
      call prntcon(18,lfno)          !end condensed printing
      end
c
      SUBROUTINE CONCD (MSIZE,NSETS,XDIM,LABELS,NSTAR,DIM)
      IMPLICIT REAL (A-H,O-Z)
C
C         SUBROUTINE CONCARD READS Galileo CONTROL CARDS AND
C         SETS UP THE JOB PARAMETERS
C
C
      INTEGER XDIM(40,40),NSTAR(40,40),DIM(40),KLUGE(40)
      CHARACTER*4 CODE,LT
C      CHARACTER*5 CHR2
      INTEGER AX,PAIRS
      CHARACTER*20 FORM
      CHARACTER*4 CRIT,CONL,OPER,SPEC
      CHARACTER*4 AMGCD,EFF,PRS,TGT,STRT,IPLT
      INTEGER STATIC,DYNAM,STA
      INTEGER TRF,QUE
      CHARACTER*4 CMD2(17),CMD3(20)
      INTEGER AMG,ST,TG
      CHARACTER*4 APP,APP1,OPTI
      CHARACTER*1 CHK(8)
C RZ CHARACTER
      CHARACTER*1 CHR(76)
      CHARACTER*1 BLNK
      INTEGER OPT,UNMASS
C
      REAL MAXVAL
C
      CHARACTER * 40 RUN
      CHARACTER*40 LABELS(40)
C
      COMMON/AXIS/AX(3)
      COMMON/AMGCOM/ST,TG,AMG(4)
      COMMON/DYNAM/DYNAM
      COMMON/EXVAL/EXVAL
      COMMON/HGTLET/HGTLET
      COMMON/KJOB/KJOB
      COMMON/LFN/LFNI,LFNO,LFNP
      COMMON/MAXITR/MAXITR
      COMMON/MAINT/MAINV
      COMMON/MAXVAL/MAXVAL
      COMMON/MIDDLE/MIDDLE
      COMMON /NOADR/NOADR
      COMMON/MSG/MSG(4)
      COMMON/PARM/BOXD,SIZE,MWAVE,LYPE,NCOLOR,NVIEW(4),NAME(2)
      COMMON/PCT/PCT
      COMMON/OPT/OPT(30)
      COMMON/PLT/PLT
      COMMON/QUE/QUE
      COMMON/RAWDAT/IDLEN,PAIRS,FORM
      COMMON/REFL/REFL
      COMMON/RUN/RUN
      COMMON/SELECT/MSK,CHK,LOGIC
      COMMON/STATIC/STATIC
      COMMON/TRF/TRF
      COMMON/THINC/THINC
      COMMON/UNMASS/UNMASS
      COMMON/XE/XE
      COMMON/YE/YE
      COMMON/ZE/ZE
      COMMON/ROT/ROTT
C
      COMMON/AP/AP
      CHARACTER*4 IREAD
      CHARACTER*4 ENDO,ENDA,ENDS
C      DATA LA,LD,LC,LP,LR,LS,LB/'A','D','C','P','R','S','B'/
      DATA MAXOP/30/
      DATA CRIT/'CRIT'/
      DATA CONL/'CONL'/
      DATA OPER/'OPER'/
      DATA OPTI/'OPTI'/
      DATA SPEC/'SPEC'/
      DATA AMGCD/'AMG '/
      DATA PRS /'PAIR'/
      DATA EFF /'EFFE'/
      DATA TGT /'TARG'/
      DATA IPLT/'PLOT'/
      DATA STRT/'STAR'/
      DATA ENDO/'ENDO'/
      DATA APP/'APPR'/
      DATA APP1/'APRO'/
      DATA ENDA/'ENDA'/
      DATA ENDS/'ENDS'/
      DATA NCMD2/16/
      DATA NCMD3/20/
      DATA IREAD/'READ'/
      DATA CMD2/'BOXD','LETT','SIZE','XEYE','YEYE','ZEYE',
     +'ROTA','TIME','COLO','VIEW','NAME','QUEU','END ','ENDO',
     +'QUE','AXIS','UNIT'/
      DATA CMD3/'MAXI','EXTR','MAIN','ADDR',
     +'UNAD','IDLE','PAIR','MIDP','SELE',
     +'EXCL','MAXI','SROT','TOLL','END ','ENDO',
     +'MAXV','EXVA','ID L','THET','FORM'/
      DATA BLNK/' '/
C
C SET DEFAULTS IN XDIM AND NSTAR OF ALL 0S AND ALL 1S RESPECTIVELY
C
      DO 1707 I=1,MSIZE
      DO 1707 J=1,MSIZE
      XDIM(I,J)=0
      NSTAR(I,J)=1
1707    CONTINUE
C
C MAKE ALL CONLABELS 0 BY DEFAULT
      DO 1708 I=1,40
      DO 1708 J=1,40
      LABELS(I)(J:J)=BLNK
1708  CONTINUE
C
C         READ CARDS,SET PARAMETERS,AND PRINT CONTROL LIST
C
C              OPTIONAL LABELS
C
40       CONTINUE
   30 FORMAT(A4,76A1)
      READ(LFNI,30) CODE,(CHR(I),I=1,76)
      WRITE(LFNO,5050) CODE,CHR
 5050 FORMAT(31X,A4,76A1)
   50 IF (CODE.EQ.CRIT ) GO TO 40
C
60    IF(CODE.NE.CONL)GO TO 70
      DO 62 K=1,MSIZE
      READ(LFNI,63) LABELS(K)
c      print*,' in concrd, labels(k) is ', labels(k), k   ! ** debug
   63 FORMAT(15X,A40)
      WRITE(LFNO,5051) LABELS(K)
 5051 FORMAT(46X,A40)
   62 CONTINUE
      GO TO 40
C
C
C              OPERATION TO BE PERFORMED
C
   70 IF (CODE.NE.OPER) GO TO 900
C RZ  DEBUG
C      WRITE(LFNO,9876)CODE,CHR(12),CHR(15),LC,LR,LD
 9876 FORMAT(' *CODE= ',A4,'*CHR(12) = ',A1,'*CHR(15)= ',A1,
     +'*LCLRLD ',3A1)
C
      IF(CHR(12).NE.'A')GO TO 710
      KJOB=5
      GO TO 40
C
710   IF(CHR(12).NE.'D')GO TO 711
      KJOB=1
      GO TO 40
C
711   IF(CHR(12).NE.'P')GO TO 1
      KJOB=4
      GO TO 40
C
1     IF(CHR(12).NE.'C')GO TO 3
      IF(CHR(15).NE.'P')GO TO 4
      KJOB=3
      GO TO 40
C
4     IF(CHR(15).NE.'R')GO TO 3
      KJOB=2
      GO TO 40
3     CONTINUE
      WRITE(LFNO,720)
  720  FORMAT(' **********ILLEGAL OPERATION**********')
      GO TO 103
C
C              SPECIFICATIONS AND OPTIONS
C
900   IF (CODE.NE.SPEC) GO TO 702
   76 READ(LFNI,30) CODE,(CHR(I),I=1,76)
      WRITE(LFNO,5050) CODE,CHR
      DO 6622 I=1,NCMD3
      IF(CMD3(I).EQ.CODE)GO TO 730
 6622 CONTINUE
C THIS IS STRANGE...THE CODE TO CHECK THE STABLE CONS OPTION IS IN A
C SUBROUTINE... SO GO  DO THIS ODD CHECK THAT BREAKS THE RULES
      GO TO 7775
730    CONTINUE
      GO TO(7175,7157,772,773,1702,1709,1705,6773,260,7715,7175,776,777,
     +40,40,7156,7157,1709,7104,1701,11911), I
C
 7156 CALL REALs( CHR,12,26,MAXVAL)
c 		print*,' at 353 maxval is  ',maxval ! ** debug
      GO TO 76
C
C UNIT MASS
C
11911 CALL INTs(CHR,12,26,UNMASS)
      GO TO 76
7157  CALL REALs( CHR,12,26,EXVAL)
      GO TO 76
C
 7104     CALL REALs(CHR,12,26,THINC)
      GO TO 76
C
772   CONTINUE
      CALL INTs(CHR,12,26,MAINV)
      GO TO 76
C
773    CONTINUE
      NOADR=0
      GO TO 1701
C
 1702  CONTINUE
      NOADR=1
      GO TO 76
1701  READ(LFNI,1704) FORM
c		print*, 'Here I am in line 375 and FORm is ',form  ! ** debug
1704  FORMAT(A16)
      GO TO 76
C
1709  CALL INTs(CHR,12,26,IDLEN)
      IF(IDLEN.LE.8)GO TO 76
      WRITE(LFNO,775)
  775 FORMAT(' **********MAXIMUM ID LENGTH IS 8***********')
      GO TO 103
C
 1705  CONTINUE
      CALL INTs(CHR,12,26,PAIRS)
      IF (PAIRS.LE.30)GO TO 76
      WRITE(LFNO,7196)
 7196 FORMAT(' **********MAXIMUM NO. OF PAIRS ON A CARD IS 30**********'
     +)
      GO TO 103
C
 6773 CONTINUE
      CALL INTs(CHR,12,26,MIDDLE)
      GO TO 76
C
  260 CONTINUE
      LOGIC=1
C
744   DO 261 J=12,19
      CHK(J-11)=CHR(J)
261   CONTINUE
      MSK=1
      GO TO 76
C
 7715 CONTINUE
      LOGIC=0
      GO TO 744
C
 7175 CONTINUE
      CALL INTs(CHR,12,26,MAXITR)
      GO TO 76
C
 7775 CALL SCON(CODE,STA,1,NSTAR,MSIZE,NSETS,XDIM,CHR)
      IF(STA.EQ.0)GO TO 11011
      WRITE(LFNO,11012)
11012 FORMAT(' **********ILLEGAL SPECIFICATION CARD OR MISSING END OF SP
     +ECIFICATION CARD**********')
      GO TO 103
11011 CONTINUE
      TRF=1
      GO TO 76
C
  776 CONTINUE
      TRF=2
C USE THE DIM ARRAY AS TEMPORARY STORAGE FOR THE STABLE ROTATE CONCPTS
C USE XDIM AS THE TEMPORARY STORAGE FOR SCON
      CALL INTN(CHR,KNT,DIM)
C KNT  IS THE COUNT OF THE CONCPTS
      DO 6619 IST=1,KNT
      READ(LFNI,30) CODE,(CHR(I),I=1,76)
      WRITE(LFNO,5050) CODE,CHR
      CALL SCON(LT,STA,DIM(IST),NSTAR,MSIZE,NSETS,XDIM,CHR)
      IF(STA)6620,6619,6620
6619  CONTINUE
      GO TO 76
C
6620  WRITE(LFNO,6621) CODE,CHR
6621  FORMAT(' *****',A4,76A1,' CARD READ WHEN STABLE CONS OR FREE C
     +CONS CARD EXPECTED')
      GO TO 103
C
  777 CONTINUE
      CALL REALS(CHR,12,26,TOL)
      GO TO 76
C
C
C
702   IF(CODE.NE.OPTI   )GO TO 2
C
C SET THE "BITS" CORRESPONDING TO THE OPTIONS SELECTED (UNDER THE CONTRO
C OF THE INDIVIDUAL OPERATIONS)
      CALL INTN(CHR,KNT,KLUGE)
      IF(KLUGE(1))9100,40,9100
 9100 DO 310 M=1,KNT
      IF(KLUGE(M)-MAXOP)2611,2611,3265
3265  WRITE(LFNO,11312) KLUGE(M)
11312 FORMAT(I10,' IS NOT A LEGAL OPTION...IGNORED')
      GO TO 310
2611  KKKKKK=KLUGE(M)
      OPT(KKKKKK)=1
310   CONTINUE
      GO TO 40
C
2     IF(CODE.NE.AMGCD)GO TO 7001
 7003 READ(LFNI,30) CODE,(CHR(I),I=1,76)
      WRITE(LFNO,5050) CODE,CHR
      IF(CODE.EQ.ENDO)GO TO 7004
      IF(CODE.EQ.ENDA)GO TO 7004
      IF(CODE.EQ.ENDS)GO TO 7004
      IF(CODE.EQ.CMD2(13))GO TO 7004
      IF(CODE.NE.TGT)GO TO 7005
      CALL INTs(CHR,12,26,TG)
      GO TO 7003
C
7005  IF(CODE.NE.STRT)GO TO 7007
      CALL INTs(CHR,12,26,ST)
      GO TO 7003
C
 7007 IF(CODE.NE.PRS)GO TO 7012
      CALL INTN(CHR,KNT,KLUGE)
      DO 7010 I=1,KNT
      KKKKKK=KLUGE(I)
      AMG(KKKKKK)=1
 7010 CONTINUE
      GO TO 7003
C
7012  IF(CODE.NE.EFF)GO TO 7023
      AMG(1)= -1
C     CALL INTN(CHR,MSG,KNT)
      GO TO 7003
C
7023  IF(CODE.NE.APP)GO TO 7024
7025  CALL REALs(CHR,12,26,AP)
      GO TO 7003
7024  IF(CODE.EQ.APP1)GO TO 7025
      WRITE(LFNO,7013)
 7013 FORMAT(' ********** THE PRECEDING CARD IS NOT A LEGAL AMG CONTROL
     +CARD **********')
      GOTO 103
C
7004  IF(TG.NE.0)GO TO 7014
      WRITE(LFNO,7015)
7015  FORMAT(' ********** NO TARGET SPECIFIED FOR AMG **********')
      GO TO 103
C
7014  IF(ST.NE.0)GO TO 40
      WRITE(LFNO,7016)
7016  FORMAT(' **********NO START SPECIFIED FOR AMG**********')
      GO TO 103
C
 7001 IF(CODE.NE.IPLT   )GO TO 90
      PLT=1
500   CONTINUE
      READ(LFNI,30) CODE,(CHR(I),I=1,76)
      WRITE(LFNO,5050) CODE,CHR
C
      DO  6720 I=1,NCMD2
      IF(CODE.EQ. CMD2(I))GO TO 604
 6720 CONTINUE
580   WRITE(LFNO,411)
  411 FORMAT(' ********** PLOTTER CONTROL CARD ERROR ABOVE **********')
      GO TO 103
C
  604 CONTINUE
      GO TO (501,502,503,7149,504,520,522,550,526,505,506,507,
     +40,40,507,1604), I
C
  550 CONTINUE
      IF(CHR(12).NE.'S')GO TO 512
      STATIC=1
      DYNAM=0
      GO TO 500
506   CONTINUE
      GO TO 500
C
512   IF(CHR(12).NE.'D')GO TO 513
      DYNAM=1
      STATIC=0
      GO TO 500
C
513   IF(CHR(12).NE.'B')GO TO 580
      DYNAM=1
      STATIC=1
      GO TO 500
C
  501 CONTINUE
      CALL REALs(CHR,12,26,BOXD)
      GO TO 500
C
  502 CONTINUE
      CALL REALS(CHR,12,26,HGTLET)
      GO TO 500
C
  503 CONTINUE
      CALL REALs(CHR,12,26,SIZE)
      GO TO 500
C
 7149 CONTINUE
      CALL REALs(CHR,12,26,XE)
      GO TO 500
C
  504 CONTINUE
      CALL REALs(CHR,12,26,YE)
      GO TO 500
C
  520 CONTINUE
      CALL REALs(CHR,12,26,ZE)
      GO TO 500
C
  522 CONTINUE
      CALL REALs(CHR,12,26,ROTT)
      GO TO 500
C
C
  526 CONTINUE
      CALL INTs(CHR,12,26,NCOLOR)
      GO TO 500
C
  505 CONTINUE
      CALL INTN(CHR,KNT,KLUGE)
      DO 1571 I=1,KNT
      IF(KLUGE(I).LE.0)GO TO 1570
      IF(KLUGE(I).GT.4)GO TO 1570
      KKKKKK=KLUGE(I)
      NVIEW(KKKKKK)=1
      GO TO 1571
 1570 CONTINUE
      WRITE(LFNO,71045) KLUGE(I)
71045    FORMAT(I10, 'IS AN ILLEGAL OPTION NUMBER...IGNORED')
 1571    CONTINUE
      GO TO 500
C
C
 507  CALL INTs(CHR,12,26,QUE )
      GO TO 500
C
1604  CALL INTN(CHR,KNT,AX)
      GO TO 500
C
C
C         ASDSIGN DEFAULT VALUES AND RETURN TO Galileo DRIVER
C
90    IF(CODE.EQ.IREAD)GO TO 200
1101  WRITE(LFNO,101)
  101 FORMAT(' ********** Galileo CONTROL CARD ERROR AT LAST PRINTED CAR
     +D **********')
103   STOP
C
  200 CONTINUE
C
C    SD 5-2-91 MOVED THIS TO MTRIX TO READ IN MULTIPLE DATA SETS.

      THINC=THINC*3.141592654/180.
      IF(OPT(8).NE.0)OPT(28)=1
      IF(OPT(10).NE.0)OPT(30)=1
      RETURN
C     DEBUG SUBCHK
      END
c
c
      SUBROUTINE INTs(IN,FR,TO,NUM)
      INTEGER ATOI
      INTEGER FR,TO
      CHARACTER*1 IN(76),ZERO,BLNK !NINE
      DATA ZERO,BLNK/'0',' '/      !,NINE/'9'/
C
      NUM=0
      DO 1 I=FR,TO
      IF(IN(I).EQ.BLNK)GO TO 1
      IF(IN(I).LT.ZERO)GO TO 2
      NUM=NUM*10+ATOI(IN(I))
1     CONTINUE
2     RETURN
C     DEBUG SUBCHK
       END
c
      SUBROUTINE REALS(IN,FR,TO,VAL)
      REAL MULT,VAL
      INTEGER FR,TO
C RZ 10/85 CHARACTER
      CHARACTER*1 IN(76)
c      CHARACTER*1 ZERO,BLNK,MINUS !NINE
      character*1 ess,blnk,period,zero,minus,ichr,two  !Feb 24, 2013
      DATA PERIOD,ZERO,BLNK,MINUS/'.','0',' ','-'/    !NINE,/'9'/
C
C CHANGED CALLS FROM FUNCTION 'ATOI' TO FUNCTION 'ATOR'
C 10/24/85 BY M.F.
C CHANGED PART OF PROGRAM THAT EVALUATES FRACTIONAL PART
C OF REAL NUMBER TO WORK IN LOOP TO EVALUATE ENTIRE FRACTION.
C PREVIOUS VERSION ONLY EVALUATED FIRST DIGIT OF FRACTION.
C 10/24/85 M.F.
CRZ DEBUG
C     PRINT*,' IN = ',IN
      DO 5 I=FR,TO
      IF(IN(I).EQ.MINUS) MFLG = 1
5     CONTINUE
C
      VAL=0
      DO 10 I=FR,TO
      IF(IN(I).EQ.PERIOD)GO TO 2
      IF(IN(I).EQ.BLNK)GO TO 3
      IF(IN(I).LT.ZERO)GO TO 3
      VAL=VAL*10+ATOR(IN(I))
10    CONTINUE
3     IF(MFLG.EQ.0) THEN
C     PRINT*,' VAL = ',VAL
      RETURN
      ENDIF
c      VAL = -VAL ! ** debug could this be the rascal? jw 3/2/13
      RETURN
C MF  FOLLOWING SECTION OF CODE WAS CHANGED TO HANDLE
C     FRACTIONS SMALLER THAN TENTHS.
2     MULT=.1
      DO 4 J=I+1,TO
      IF(IN(J).EQ.BLNK)GO TO 3
      IF(IN(J).LT.ZERO)GO TO 3
      VAL=VAL+(ATOR(IN(J))*MULT)
      MULT=MULT/10.
4     CONTINUE
      GO TO 3
C     DEBUG SUBCHK
      END
c
      SUBROUTINE INTN(IN,NC,NUMS)
      INTEGER OUT,ATOI
      CHARACTER*1 IN(76),ZERO,BLNK,COMMA,BLANK
      INTEGER NUMS(40)
      INTEGER FR,TO
      DATA ZERO,COMMA,BLNK/'0',',',' '/
      DATA BLANK/' '/
C
      NC=0
      OUT=0
      FR=12
      TO=80
      DO 7 FR = 12,80
      IF(IN(FR).NE.BLANK)GO TO 8
7     CONTINUE
      RETURN
8     CONTINUE
      DO 1 I=1,60
      NUM=0
      DO 2 J=FR,TO
      IF(IN(J).EQ.BLNK)GO TO 5
      IF(IN(J).EQ.COMMA)GO TO 4
      IF(IN(J).LT.ZERO)GO TO 5
      NUM=NUM*10+ATOI(IN(J))
2     CONTINUE
C
5     OUT=1
C
4     NUMS(I)=NUM
      FR=J+1
      NUM=0
      IF(OUT.NE.0)GO TO 3
1     CONTINUE
C
3     NC=I
      RETURN
C     DEBUG SUBCHK
      END
c
      INTEGER FUNCTION ATOI(IX)
      CHARACTER*1 DIGIT(10),BLNK,COMMA,PERIOD,MINUS,IX
      DATA DIGIT/'0','1','2','3','4','5','6','7','8','9'/
      DATA BLNK,COMMA,PERIOD,MINUS/' ',',','.','-'/
C
C A TRANSFER FUNCTION FROM CHARACTERS TO INTEGERS
C 0-9 MAP TO 0-9
C . MAPS TO 10
C  MAPS TO 11
C , MAPS TO 12
C - MAPS TO 13
C ALL ELSE MAP TO -1
C
      IF(IX.NE.BLNK)GO TO 1
      ATOI=11
      RETURN
1     IF(IX.NE.COMMA)GO TO 2
      ATOI=12
      RETURN
2     IF(IX.NE.PERIOD)GO TO 5
      ATOI=10
      RETURN
5     IF(IX.NE.MINUS)GO TO 3
      ATOI=13
      RETURN
3     DO 4 I=1,10
      IF( IX.NE.DIGIT(I))GO TO 4
      ATOI=I-1
      RETURN
4     CONTINUE
      ATOI= -1
      RETURN
      END
c
      REAL FUNCTION ATOR(IX)
      CHARACTER*1 DIGIT(10),BLNK,COMMA,PERIOD,MINUS,IX
      DATA DIGIT/'0','1','2','3','4','5','6','7','8','9'/
      DATA BLNK,COMMA,PERIOD,MINUS/' ',',','.','-'/
C
C A TRANSFER FUNCTION FROM CHARACTERS TO INTEGERS
C 0-9 MAP TO 0-9
C . MAPS TO 10
C  MAPS TO 11
C , MAPS TO 12
C - MAPS TO 13
C ALL ELSE MAP TO -1
C
C REWROTE THIS OLDER VERSION OF 'ATOI' TO 'ATOR'
C ON 10/24/85 BY M.F.
      IF(IX.NE.BLNK)GO TO 1
      ATOR=11
      RETURN
1     IF(IX.NE.COMMA)GO TO 2
      ATOR=12
      RETURN
2     IF(IX.NE.PERIOD)GO TO 5
      ATOR=10
      RETURN
5     IF(IX.NE.MINUS)GO TO 3
      ATOR=13
      RETURN
3     DO 4 I=1,10
      IF( IX.NE.DIGIT(I))GO TO 4
      ATOR=I-1
      RETURN
4     CONTINUE
      ATOR= -1
      RETURN
      END
c
      FUNCTION SQRTT(X)
      REAL X
      IF(X)1,2,3
1     SQRTT=-SQRT(-X)
      RETURN
C
    2 SQRTT=0
      RETURN
C
    3 SQRTT=SQRT(X)
      RETURN
      END
c
      SUBROUTINE SCON(LT  ,STA,KP,NSTAR,MSIZE,NSETS,NCON,CHR)
c
      INTEGER STAB,FREE,STA
      CHARACTER*1 CHR(76)
      CHARACTER*4 LT
      INTEGER NSTAR(40,40),KP,NCON(40)
      COMMON/KSTAR/KSTAR
      CHARACTER*4 SCN,FCON       !,CODE
      DATA SCN/'SCON'/
      DATA FCON/'FCON'/
C
      STA=1
      IF(LT.NE.SCN)GO TO 76
      STA=0
      FREE=0
      STAB=1
   22 CALL INTN(CHR,KNT,NCON)
C
C THIS IS THE ROUTINE THAT DOES THE WORK OF THE STABLE CONS LOGIC
C FREE IS THE CODE USED TO DENOTE THE FREE CONCPT (0)
C STAB IS THE VALUE USED TO DENOTE THE FREE MOVING CONCPT (1)
C ON A STABLE CONS CARD, FREE IS SET TO 0 AND ALL ELEMENTS OF NSTAR ARE
C TO THE VALUE AND THOSE STABLE CONCPTS ARE FLAGED WITH A 1
C ON A FREE CONS CARD, THE SETUP IS JUST THE OPPOSITE
      DO 20 I=1,MSIZE
      NSTAR(I,KP)=FREE
   20 CONTINUE
      DO 21 I=1,KNT
      NNNNNN=NCON(I)
      NSTAR(NNNNNN,KP)=STAB
   21 CONTINUE
      IF(KP.EQ.1)KSTAR=KNT
      RETURN
C
   76 IF(LT.NE.FCON)RETURN
      STA=0
      FREE=1
      STAB=0
      GO TO 22
C     DEBUG SUBCHK
      END
c
      SUBROUTINE MTRIX(MSIZE,NSETS,SMEAN,Y,BUF,
     +EXTRA1,EXTRA2,EXTRA3,OPTION)
C
C         SUBROUTINE MTRIX WILL READ IN RAW DATA PAIRS FROM
C         ANY Galileo QUESTIONNAIRE USING STANDARDIZED FORMAT.
C         IT WILL COMPUTE THE MEAN VALUES MATRIX FOR THAT
C         DATA AND CAN PRINT THE MATRIX AND A SAMPLE SIZE
C         TABLE.  IN ADDITION MTRIX WILL PUNCH THE MEAN VALUES
C         MATRIX FOR FURTHER Galileo PROCESSING NOT REQUIRING
C         RAW DATA INPUT.  THE USER SHOULD REFER TO THE Galileo
C         ABSTRACT FOR INSTRUCTIONS ON USING THE SUBROUTINE
C
      IMPLICIT REAL (A-H,O-Z)
      DIMENSION EXTRA1(40,40)
      DIMENSION EXTRA2(40,40)
      DIMENSION EXTRA3(40,40)
      DIMENSION JC(30),JR(30),DIST(30)
      CHARACTER * 40 RUN
      DIMENSION SMEAN(40,40),Y(40,40),BUF(1600)
C
      INTEGER ROW,COL
      INTEGER OPTION
      INTEGER WRITES
      INTEGERERR
      CHARACTER*1 STAR
      CHARACTER*20 FORM
      CHARACTER*80 DFILE    !SD 5-2-91 FOR MULT DSETS
      INTEGER PAIRS,CDS,CNT,PRS
      CHARACTER*1 TEMP(8),CHK(8)
      INTEGER EIG,ROT,RD      !,TRY
      INTEGER MSK
      INTEGER OPT(30)
C
      REAL MAXVAL
C
      COMMON/BASE/MNS,EIG,ROT,RD
      COMMON/EXVAL/EXVAL
      COMMON/LFN/LFNI,LFNO,LFNP
      COMMON/MAXVAL/MAXVAL
      COMMON/WRITES/WRITES
      COMMON/K4NSET/K4NSET
      COMMON/NOADR/NOADR
      COMMON/OPT/OPT
      COMMON/RAWDAT/IDLEN,PRS,FORM
      COMMON/RUN/RUN
      COMMON/SELECT/MSK,CHK,LOGIC
      DATA STAR /'*'/
      DATA FORM /'(8A1,8(2I2,F5.0))'/ ! moved from block data Feb 28, 2013 jw
      DATA IDLEN,PAIRS/8,8/ ! ** moved from block data Feb 28, 2013 jw
      data prs/8/  ! ** made up to give pairs a good value Feb 28, 2013 jw


      LFNI=56
c      print*,' lfno at line 902 is ',lfno
C
C
C         READ AND CLEAN DATA - PERFORM SUMMING OPERATIONS
C
C  SET UP THE 'CONSTANTS' NEEDED
      ERR=OPT(22)
      STAT=OPT(18)
C
      MS=1590
      MS1=MSIZE-1
c      LSIZE=MSIZE/8.+.9
		lsize = msize/8 ! ** debug replacing a meaninless (to me) statement... jw
c		print*, ' at 914 lsize is  ', lsize ! ** debug jw
C
C
      DO 611 K4NSET=1,NSETS
      READ(55,1011)DFILE
 1011 FORMAT(A80)
      OPEN(UNIT=LFNI,FILE=DFILE,STATUS='OLD')
C
C SMEAN AND Y ARE NOW THE SAME MATRIX
C UPPER HALF TAKES THE COUNTS OF CELLS
C LOWER HALF TAKES THE SUMS OF CELLS
C WRITES IS THE  'WRITES TO THE RANDOM FILE' COUNTER
C KV IS THE CASE BUFFER COUNTER
C M IS THE CARD COUNTER FOR DIAGNOSTICS
      KV=1
      M=0
      WRITES=0
      DO 5 I=1,MSIZE
      DO 5 J=1,MSIZE
      SMEAN(I,J)=0.0
5     CONTINUE
      DO 1225 II=1,1600
      BUF(II)=0.0
 1225 CONTINUE
C
      call prntcon(12,lfno)
      WRITE(LFNO,10) RUN,K4NSET
   10 FORMAT (38X,A40,5X,'Raw data set number',I3//)
      KLEAN=0
      IF(NOADR.NE.0)GO TO 401
C
C THE CELL ADDRESS METHOD
c      PRINT*, 'Reading data set ',k4nset
c      PRINT*, ' HERE IS FORM, idlen, prs, ', FORM,idlen,prs  ! ** DEBUG
 1000 READ(LFNI,FORM,END=110)
     +(TEMP(I),I=1,IDLEN),(JC(I),JR(I),DIST(I),I=1,PRS)
c      print*,' at 945 temp(i),jc(i), jr(i), dist(i), i ',temp(i-1),
c     +jc(i-1),jr(i-1),dist(i-1),i ! ** debug
  120 M=M+1
1200	 IF(MSK.EQ.0)GO TO 1001
      IF(LOGIC.EQ.0)GO TO 1101
      DO 1002 I=1,IDLEN
      IF(CHK(I).EQ.STAR)GO TO 1002
      IF(TEMP(I).NE.CHK(I))GO TO 1000
1002  CONTINUE
      GO TO 1001
1101  DO 1003 I=1,IDLEN
      IF(CHK(I).EQ.STAR)GO TO 1003
      IF(TEMP(I).EQ.CHK(I))GO TO 1000
1003  CONTINUE
1001  CONTINUE
      DO 130 I=1,PRS
      J=JC(I)
      K=JR(I)
C
      IF (J.EQ.K)GO TO 130
49    IF (J.EQ.0.AND.K.EQ.0) GO TO 130
45    IF (J.GT.0.AND.J.LE.MSIZE) GO TO 128
      IF(ERR.NE.0)CALL BADRD(M,TEMP,K,J,0.,I,-1)
      KLEAN=KLEAN+1
      GO TO 130
C
  128 IF (K.GT.0.AND.K.LE.MSIZE) GO TO 127
      IF(ERR.NE.0)CALL BADRD(M,TEMP,K,J,0.,I,-1)
      KLEAN=KLEAN+1
      GO TO 130
C
  127 IF  (J.NE.K) GO TO 129
      IF(ERR.NE.0)CALL BADRD(M,TEMP,K,J,0.,I,-1)
      GO TO 130
C
 129  IF(J.LT.K)GO TO 1130
C
C FLOP DISTANCE ADDRESSES OF INVERTED ORDER   (TAYLOR'S CONDITION)
      IT=J
      J=K
      K=IT
c1130 		print*, 'maxval at 994 = ',maxval  ! ** debug don't forget to drop 1130 one line
1130      IF (DIST(I)-MAXVAL) 140,140,141
      
141   IF(ERR.NE.0)CALL BADRD(M,TEMP,K,J,DIST(I),I,0)
      GO TO 130
C
C***************** A PAIRED COMPARISON MADE IT*****************
  140 IF(DIST(I).EQ.-1)GO TO 1
      SMEAN(K,J)=SMEAN(K,J)+DIST(I)
      Y(J,K)=Y(J,K)+1
C
C IF INDICATED, ACCUMULATE RAW DATA INFO. FOR STATISTICS
      IF(STAT.EQ.0)GO TO 1
      BUF(KV)=J
      BUF(KV+1)=K
      BUF(KV+2)=DIST(I)
      KV=KV+3
      IF(KV-MS)1,2,2
2     WRITES=WRITES+1
      CALL PUT(RD+WRITES,MSIZE,BUF)
      KV=1
1     CONTINUE
      IF(ERR.GE.0)GO TO 130
      IF(DIST(I).LE.EXVAL)GO TO 130
      CALL BADRD(M,TEMP,K,J,DIST(I),I,1)
  130 CONTINUE
      GO TO 1000
C
C
C THE NO-CELL ADDRESS METHOD
C
401   PAIRS=MSIZE*(MSIZE-1)/2
      CDS=PAIRS/PRS
      IF((CDS*PRS).LT.PAIRS)CDS=CDS+1
  402 READ(LFNI,FORM,END=110) (TEMP(I),I=1,IDLEN),(DIST(I),I=1,PRS)
      COL=1
      ROW=1
      M=M+1
406   IF(MSK.EQ.0)GO TO 404
      IF(LOGIC.EQ.0)GO TO 1207
      DO 1208 I=1,IDLEN
      IF(CHK(I).EQ.STAR)GO TO 1208
      IF(CHK(I).NE.TEMP(I))GO TO 1209
1208  CONTINUE
      GO TO 404
1207  DO 1211 I=1,IDLEN
      IF(CHK(I).EQ.STAR)GO TO 1211
      IF(CHK(I).EQ.TEMP(I))GO TO 1209
1211   CONTINUE
      GO TO 404
1209  CONTINUE
C SKIP THE REST OF THIS SUBJECT
      DO 408 I=2,CDS
      READ(LFNI,99) TEMP
99     FORMAT(8A4)
408   CONTINUE
C INCREMENT M BY THE CDS PER SUBJECT
      M=M+CDS-1
      GO TO 402
C
404   CNT=1
C COUNT OF REMAINING CARDS...USED TO TELL WHEN TO RESET
413   DO 407 I=1,PRS
      COL=COL+1
      IF(COL.LE.MSIZE)GO TO 3
      ROW=ROW+1
      IF(ROW.GE.MSIZE)GO TO 407
      COL=ROW+1
C
C THE ONLY WAY TO DO MISSING DATA IS BY BLANK DISTANCES IN THIS MODE
3     IF(DIST(I).LT.0)GO TO 407
C
c		print*,' at 1066,  = ',maxval  ! ** debug
      IF(DIST(I).LE.MAXVAL)GO TO 23
      IF(ERR.GE.0)GO TO 407
      CALL BADRD(M,TEMP,COL,ROW,DIST(I),I,0)
      KLEAN=KLEAN+1
      GO TO 407
C
23    IF(DIST(I).LE.EXVAL)GO TO 411
      IF(ERR.GE.0)GO TO 407
      CALL BADRD(M,TEMP,COL,ROW,DIST(I),I,1)
C
411   SMEAN(ROW,COL)=SMEAN(ROW,COL)+DIST(I)
      Y(COL,ROW)=Y(COL,ROW)+1
C
      IF(STAT.EQ.0)GO TO 407
      BUF(KV)=ROW
      BUF(KV+1)=COL
      BUF(KV+2)=DIST(I)
      KV=KV+3
      IF(KV.LT.MS  )GO TO 407
C IF IT REACHES THE MAGIC NUMBER...WRITE IT OUT
      WRITES=WRITES+1
      CALL PUT(RD+WRITES,MSIZE,BUF)
      KV=1
407   CONTINUE
C
      READ(LFNI,FORM) TEMP(I),(DIST(I),I=1,PRS)
      CNT=CNT+1
      IF(CNT.GT.CDS)GO TO 402
      M=M+1
      GO TO 413
C
110   IF(STAT.EQ.0)GO TO 7
      IF(KV-1)7,7,4
4     WRITES=WRITES+1
      DO 8 I=KV,MS
      BUF(I)=0.
8     CONTINUE
      CALL PUT(RD+WRITES,MSIZE,BUF)
C
c7		print*, ' at 1098 klean is   ',klean   ! ** debug jw (Don't forget to move 7 down one line
7      IF(KLEAN)112,112,111
  112 WRITE(LFNO, 113)  K4NSET
c  	  print*, ' this is were we say the data was properly stored. ' ! ** debug jw 

  113 FORMAT ('0',10X,'Data in set ',I3,' was properly stored')
      GO TO 115
111   WRITE(LFNO,114) KLEAN,K4NSET
c		print*, ' might as well say how many errors were found...', klean ! ** debug
114   FORMAT('0',I10,' errors detected in data set ',I3)
C
C         CALCULATION OF MEANS MATRIX
C
115   ZRCELL=0
c		print*, ' Starting to calculate the means...  '  ! ** debug jw
      DO 210 J=1,MS1
      MSI=J+1
      DO 210 K=MSI,MSIZE
      ASUM=SMEAN(K,J)
      AN=Y(J,K)
      IF (AN) 231,230,231
  230 SMEAN(J,K)=0.0
      ZRCELL=1
      GO TO 210
  231 SMEAN(K,J)=ASUM/AN
  210 CONTINUE
      IF(ZRCELL.NE.0)CALL NULCEL (MSIZE,SMEAN,Y)
      IF(STAT.NE.0)CALL STATS(MSIZE,SMEAN,Y,EXTRA1,EXTRA1,EXTRA2,EXTRA2
     +,EXTRA3,EXTRA3,BUF)
C     IF(STAT.NE.0)CALL STATS(MSIZE,SMEAN,Y,BUF)
C
C         MATRIX PRINTOUT OPERATION
C
      IF(OPT(4).EQ.0)GO TO 4101
      call prntcon(12,lfno)
      WRITE(LFNO,50) RUN,K4NSET
  50  FORMAT(32X,A40,2X,'-- Galileo Means Matrix',20X,
     + 'SET NO. ',I3)
      K1=1
c      PRINT*, ' at 1137 LSIZE =  ', LSIZE ! ** debug jw
      DO 4100L=1,LSIZE
      K2=K1+7
      K2=MIN0(K2,MSIZE)
C     WRITE(LFNO,50) RUN,K4NSET
C  50 FORMAT ('2',35X,A40,2X,'--Galileo MEANS MATRIX',22X,'SET NO. ',I3
C    +)
      WRITE(LFNO,70)
      WRITE(LFNO, 60)  (K,K=K1,K2)
60    FORMAT('0',3X,8I15/)
      DO 410 J=K1,MSIZE
      K3=J
      K3=MIN0(K3,K2)
      WRITE(LFNO, 80)  J,(SMEAN(J,K),K=K1,K3)
80    FORMAT(2X,I2,8(1X,F14.3))
410   CONTINUE
      K1=K2+1
 4100 CONTINUE
C
C         SAMPLE SIZE TABULATION PRINTOUT OPERATION
C
      J1=1
      WRITE(LFNO,90) RUN,K4NSET
      call prntcon(12,lfno)
  90  FORMAT(32X,A40,2X,'-- Sample size for each pair',
     + 15X,'SET NO. ',I3)
  70  FORMAT('0')
c  		print*, ' at 1164, lsize =  ',lsize  ! ** debug jw
      DO 5100L=1,LSIZE
      J2=J1+7
      J2=MIN0(J2,MSIZE)
C     WRITE(LFNO,90) RUN
C  90 FORMAT ('2',32X,A40,2X,'-- SAMPLE SIZE FOR EACH PAIR')
      WRITE(LFNO,70)
      WRITE(LFNO, 60) (J,J=J1,J2)
      DO 510 K=J1,MSIZE
      J3=K
      J3=MIN0(J3,J2)
      WRITE(LFNO, 95)  K,(Y(J,K),J=J1,J3)
95    FORMAT(1X,I3,8(1X,F14.0))
  510 CONTINUE
      J1=J2+1
 5100 CONTINUE
4101   AMX= -1.
      AMN=1.0E10
      DO 4102 J=1,MS1
      II=J+1
      DO 4102 I=II,MSIZE
      IF(SMEAN(I,J).LE.AMX)GO TO 4108
      IRAMX=I
      ICAMX=J
      AMX=SMEAN(I,J)
C
4108  IF(SMEAN(I,J).GE.AMN)GO TO 4102
      IRAMN=I
      ICAMN=J
      AMN=SMEAN(I,J)
4102  CONTINUE
C
      WRITE(LFNO,4109)IRAMX,ICAMX,AMX,IRAMN,ICAMN,AMN
4109  FORMAT('  Cell with maximum distance is',2I3
     +,'  Distance is ',F14.4/'0 Cell with minimun distance is',
     +2I3,'  Distance is ',F14.4)
      IF(OPT(23))4104,4105,4104
4104  DO 4106 J=1,MS1
      II=J+1
      DO 4106 I=II,MSIZE
      IF(SMEAN(J,I).GE.30)GO TO 4106
      WRITE(LFNO,4107) I,J,SMEAN(J,I)
4107  FORMAT(' Cell with an N of .LT.30',2I3,'Count is',
     +F5.0)
4106  CONTINUE
4105  CONTINUE
C
C         STORAGE OF MATRIX AND CALCULATION OF SYMMETRY
C
      DO 302 K=1,MS1
      MSI=K+1
      DO 302 J=MSI,MSIZE
      SMEAN(K,J)=SMEAN(J,K)
  302 CONTINUE
      IF (OPTION) 301,301,305
  305 CALL PUT(MNS+K4NSET,MSIZE,SMEAN)
C
C         MATRIX PUNCHING OPERATION
C
301   IF(OPT(5).EQ.0)GO TO 611
      WRITE(LFNP,647) MSIZE,RUN,K4NSET
647   FORMAT('(8F10.4)',2X,I2,'Means for ',A40,' Set',I3)
      DO 610 K=1,MSIZE
      WRITE(LFNP, 11)  (SMEAN(K,J),J=1,MSIZE)
   11 FORMAT (8F10.4)
  610 CONTINUE
  611 CONTINUE
      RETURN
C     DEBUG SUBCHK
      END
c
      SUBROUTINE NULCEL (MSIZE,SMEAN,CNT)
      IMPLICIT REAL (A-H,O-Z)
      DIMENSION CNT(40,40),SMEAN(40,40)
C
C      INTEGER CNT
      COMMON/LFN/LFNI,LFNO,LFNP
C
C A ROUTINE TO INSERT MEAN OF ALL CELLS OF NON-ZERO CELL SIZE INTO
C ALL CELLS OF ZERO CELL SIZE
C
      ACN=0.
      SUM=0.
      MS1=MSIZE-1
      DO 1 J=1,MS1
      MSI=J+1
      DO 1 I=MSI,MSIZE
2     IF(CNT(J,I))1,1,3
3     SUM=SUM+SMEAN(I,J)
      ACN=ACN+1.
1     CONTINUE
C
      IF(ACN.EQ.0.)RETURN
      AMEAN=SUM/ACN
      WRITE(LFNO,100) AMEAN
100   FORMAT('  Mean of all non-zero cells ',F14.3)
      IK=0
      DO 4 J=1,MS1
      MSI=J+1
      DO 4 I=MSI,MSIZE
5     IF(CNT(J,I))6,6,4
6     IK=IK+1
      SMEAN(I,J)=AMEAN
      WRITE(LFNO,300) I,J
300   FORMAT('  ZERO-COUNT CELL ADJUSTED.  LOCATION ',2I3)
4     CONTINUE
C
      WRITE(LFNO,200) IK
200   FORMAT('  TOTAL ADJUSTED CELLS ',I5)
      RETURN
C     DEBUG SUBCHK
      END
c
      SUBROUTINE BADRD(M,TEMP,K,J,DIST,POS,TYPE)
      IMPLICIT REAL (A-H,O-Z)
      CHARACTER*1 TEMP(8)
      character*4 mess(18)
      INTEGER POS,TYPE      ! removed geb 24, 2013 ,MESS(18)
      COMMON /LFN/LFNI,LFNO,LFNP
      DATA MESS/'CELL',' ADD','RESS',' ERR','OR  ',' ',
     +'DIST','ANCE',' GT ','MAXV','AL',' ',
     +'DIST','ANCE',' GT ','EXTR','EME ','VAL'/
C
C
      IF(TYPE)1,2,3
1     WRITE(LFNO,4) (MESS(I),I=1,6),TEMP,K,J,POS
4     FORMAT(1X,6A4,8A1,3X,'ADDRESS',2I3,'POSITION',I3)
      RETURN
2     WRITE(LFNO,5)(MESS(I),I=7,12),TEMP,K,J,POS,DIST
5     FORMAT(1X,6A4,8A1,3X,'ADDRESS',2I3,'POSITION',I3,3X,'DISTANCE',
     +F6.0)
      RETURN
3     WRITE(LFNO,5) (MESS(I),I=13,18),TEMP,K,J,POS,DIST
      RETURN
C     DEBUG SUBCHK
      END
c
      SUBROUTINE STATS(MSIZE,SMEAN,Y,SDIF,SQDIF,SCUDIF,S4DIF,MIN,
     +MAX,BUF)
C     SUBROUTINE STATS(MSIZE,SMEAN,Y,BUF)
C
C THIS IS THE STATISTICS ROUTINE FOR Galileo
C CALLED FROM MTRIX. IT PRINTS
C MEAN, STANDARD DEVIATION, VARIANCE, SKEWNESS, KURTOSIS,
C MAXIMUM VALUE, MINIMUM VALUE, RANGE AND COUNT FOR EACH
C MATRIX ADDRESS WITH NON-ZERO COUNT
C ONLY HALF A MATRIX USED SO MATRICES DOING DOUBLE DUTY
C
C SDIF IS THE SUM OF X(I)-X(M)
C SQDIF IS THE SUM OF (X(I)-X(M))**2
C SCUDIF IS THE (X(I)-X(M))**3
C S4DIF IS THE SUM OF (X(I)-X(M))**4
C SMEAN IS PAIRED WITH Y   SDIF IS PAIRED WITH SQDIF   SCUDIF IS PAIRED
C S4DIF   MIN IS PAIRED WITH MAX   BUF STANDS ALONE
C
      IMPLICIT REAL (A-H,O-Z)
      REAL MIN(40,40),MAX(40,40),KRTS
C
      INTEGER EIG,ROT,RD
      INTEGER WRITES
      CHARACTER * 40 RUN
C
      DIMENSION BUF(1600),SMEAN(40,40),Y(40,40)
      DIMENSION SDIF(40,40),SQDIF(40,40),SCUDIF(40,40)
      DIMENSION S4DIF(40,40)
C
      COMMON/BASE/MNS,EIG,ROT,RD
      COMMON/WRITES/WRITES
      COMMON/LFN/LFNI,LFNO,LFNP
      COMMON/K4NSET/K4NSET
      COMMON/RUN/RUN
      COMMON/ASVAR/IVAR
      COMMON/STATI/AVEERR,MNC
C
c		Print*,' Hello from stats!, msize, lfno = ', msize, lfno    ! ** debug
      MS2=1590
      AVOBV=0.
      MS1=MSIZE-1
      MNC=0
      GMN=0.0
      DO 1 J=1,MS1
      JJ=J+1
      DO 1 I=JJ,MSIZE
      MAX(I,J)=1.0E-10
      MIN(J,I)=1.0E10
C
C CALCULATION OF TOTAL OBSERVATIONS
      AVOBV=AVOBV+Y(J,I)
C
C CALCULATION OF MEAN OF ALL NON-ZERO CELLS
      IF(Y(J,I).LE.0)GO TO 1
      GMN=GMN+SMEAN(I,J)
      MNC=MNC+ 1
1     CONTINUE
C
      AVOBV=AVOBV/MNC
      GMN=GMN/MNC
      DO 2 L=1,MSIZE
      DO 2 M=1,MSIZE
      SDIF(L,M)=0.
      SCUDIF(L,M)=0.
    2 CONTINUE
    
C
      call prntcon(12,lfno)
      WRITE(LFNO,22) RUN,K4NSET
22    FORMAT(24X,'Statistics for ',A40,' Set number ',I3//)
      WRITE(LFNO,3)
3     FORMAT(2X,'ROW',2X,'COL',5X,5X,'MEAN',4X,'STAN. DEV.',
     +11X,'  STD ERR',8X,' SKEWNESS',8X,' KURTOSIS',4X,'COUNT',2X,
     +'MIN. VAL',2X,'MAX. VAL',5X,'ERROR')
C
C      REWIND(8)
      DO 60 IW=1,WRITES
      CALL GET(RD+IW,MSIZE,BUF)
      DO 20 J=1,MS2,3
      II=INT(BUF(J))
      JJ=INT(BUF(J+1))
      DIST   =BUF(J+2)
      IF(II.EQ.0.OR.JJ.EQ.0)GO TO 6
      DIF=DIST   -SMEAN(JJ,II)
      SDIF(II,JJ)=SDIF(II,JJ)+DIF
      SQDIF(JJ,II)=SQDIF(JJ,II)+DIF**2
      SCUDIF(II,JJ)=SCUDIF(II,JJ)+DIF**3
      S4DIF(JJ,II)=S4DIF(JJ,II)+DIF**4
      IF(MIN(II,JJ).GT.DIST   )MIN(II,JJ)=DIST
      IF(MAX(JJ,II).LT.DIST   )MAX(JJ,II)=DIST
20    CONTINUE
   60 CONTINUE
C
C PRINT OUT THE RESULTS
C
6     CONTINUE
      DO 9 J=1,MS1
      JJ=J+1
      DO 9 I=JJ,MSIZE
      COUNT=Y(J,I)
      IF(COUNT.LE.1)GO TO 9
      VAR=SQDIF(I,J)/(COUNT-1)
      STDV=SQRTT(VAR)
      VAR=STDV/SQRTT(COUNT)
      IF(STDV.EQ.0)GO TO 12
      KRTS=(((S4DIF(I,J)/STDV**4)/COUNT)-3.)
      SKW=(SCUDIF(J,I)/STDV**3)/COUNT
      ICNT=COUNT
      RANGE=100*(VAR/SMEAN(I,J))
      GO TO 123
   12 KRTS=0
      SKW=0
      ICNT=COUNT
      RANGE=MAX(I,J)-MIN(J,I)
  123 CONTINUE
C
      TVAR=TVAR+VAR
      WRITE(LFNO,11) J,I,SMEAN(I,J),STDV,VAR,SKW,KRTS,ICNT,
     +MIN(J,I),MAX(I,J),RANGE
11    FORMAT(2I5,2(5X,F9.3),5X,F15.3,2(1X,F16.3),5X,I4,
     +3(2X,F8.1))
9     CONTINUE
      AVEERR=TVAR/MNC
c      PRINT*, ' Ave std err is ',aveerr
      tvar=0	! a bug fix 6/27/93 jw
C
      WRITE(LFNO,77) AVOBV
77    FORMAT('  Average observations per cell ',F10.4)
      WRITE(LFNO,97) MNC,GMN
   97 FORMAT('  Count of all non-zero cells ',I5/'  Mean of all non-zero
     + cells ',F10.4)
C
      RETURN
C     DEBUG SUBCHK
      END
c
      SUBROUTINE CNTEIG(MS,NS,LAB,NST,DIM,M1,M2,M3,M4,XDIM,
     +    V1,V2,V3,V4,V5,JOB)
      IMPLICIT REAL (A-H,O-Z)
      INTEGER XDIM(40,40),DIM(40),NST(40,40)
      REAL M1,M2,M3,M4
      COMMON/OPT/OPT
      INTEGER OPT(30)
      CHARACTER*1 LAB(60,10)
      DIMENSION M1(40,40),M2(40,40),M3(40,40),M4(40,40),
     +    V1(40),V2(40),V3(40),V4(40),V5(40),
     +IV5(40)
C
C
      GO TO (1,2,2,1),JOB
2     IF(OPT(2))8,5,8
5     DO 6 I=1,NS
      CALL CENTRX(MS,NS,I,V1,V2,M1)
      CALL EIGTRX(MS,NS,I,XDIM,LAB,NST,DIM,M1,M2,M3,M4,V3,V1,V4
     +,IV5,V2)
6     CONTINUE
      GO TO 1
8     DO 9 I=1,NS
      CALL EIGTRX(MS,NS,I,XDIM,LAB,NST,DIM,M1,M2,M3,M4,V3,V1,V4
     +,IV5,V2)
9     CONTINUE
1     CONTINUE
      RETURN
C     DEBUG SUBCHK
      END
c
      SUBROUTINE CENTRX(MSIZE,NSETS,INCMNT,SQJ,SQK,SMEAN)
C
C         SUBROUTINE CENTRIX WILL COMPUTE A DOUBLE CENTERED
C         CENTROID SCALAR PRODUCTS MATRIX ACCORDING TO THE
C         ALGORITHM PROVIDED BY YOUNG AND HOUSEHOLDER (1938)
C         AND ADAPTED BY TORGERSON (1958)
C
      IMPLICIT REAL (A-H,O-Z)
      DIMENSION SQJ(40),SQK(40),SMEAN(40,40)
      CHARACTER * 40 RUN
      character*1 dbl, hdr(3),CC ! Feb 24, 2013
C
      COMMON/BASE/MNS,EIG,ROT,RD
      COMMON/LFN/LFNI,LFNO,LFNP
      COMMON/MIDDLE/CONCPT
      COMMON/OPT/OPT(30)
      COMMON/RUN/RUN
C
      INTEGER EIG,ROT,RD
      INTEGER OPT
C      INTEGER HDR(3),DBL  commented out Feb 24, 2013
      INTEGER CONCPT
      DATA DBL/'0'/
C
      DO 5 K=1,MSIZE
      SQJ(K)=0.0
      SQK(K)=0.0
    5 CONTINUE
C
C         READ DATA AND/OR ARRAY MEANS MATRIX
C
      IF(OPT(1)) 11,10,11
   10 READ(LFNI,101) HDR
  101 FORMAT(2A4,A2)
      DO 20 I=1,MSIZE
      READ(LFNI,HDR) (SMEAN(I,J),J=1,MSIZE)
  100 FORMAT(8F10.0)
   20 CONTINUE
      GO TO 12
C
   11 CALL GET(MNS+INCMNT,MSIZE,SMEAN)
C
12    CONTINUE
C
C SQUARE ALL MATRIX ELEMENTS
C COMPUTE SUM OF SQUARES OF ROWS
C COMPUTE SUM OF SQUARES OF COLUMNS
C
611   SSQ=0.
      DO 50 J=1,MSIZE
      DO 50 K=1,MSIZE
      SMEAN(J,K)=SMEAN(J,K)**2
      SSQ=SSQ+SMEAN(J,K)
      SQJ(J)=SQJ(J)+SMEAN(J,K)
50    CONTINUE
C
      DO 70 K=1,MSIZE
      DO 70 J=1,MSIZE
      SQK(K)=SQK(K)+SMEAN(J,K)
   70 CONTINUE
C
C         COMPUTE EACH ELEMENT OF THE MATRIX
C
      N=MSIZE
      TERM=SSQ/MSIZE**2
      DO 80 J=1,MSIZE
      DO 80 K=1,MSIZE
      SMEAN(J,K)=((SQJ(J)/N)+(SQK(K)/N)-   TERM   -SMEAN(J,K))/2
   80 CONTINUE
C
C CENTER CENTROID ON MIDPOINT IF INDICATED
C
      IF(CONCPT.LE.0)GO TO 6
      DO 7 I=1,MSIZE
      CON=SMEAN(CONCPT,I)
      DO 7 J=1,MSIZE
      SMEAN(J,I)=SMEAN(J,I)-CON
7     CONTINUE
C
      DO 8 I=1,MSIZE
      CON=SMEAN(I,CONCPT)
      DO 8 J=1,MSIZE
      SMEAN(I,J)=SMEAN(I,J)-CON
8     CONTINUE
C
6     CONTINUE
C
C
C         STORE OR OUTPUT THE CENTROID SCALAR PRODUCTS MATRIX
C
      CC=DBL
      IF(OPT(7))612,613,612
612   WRITE(LFNP, 1   ) MSIZE,RUN,INCMNT
    1 FORMAT('(6F12.3)  ',I2,2X,A40,' SCALAR PRODUCTS MATRIX SET ',I10)
      DO 90 K=1,MSIZE
      WRITE(LFNP, 200) (SMEAN(K,J),J=1,MSIZE)
  200 FORMAT (6F12.3)
   90 CONTINUE
C
613   IF(OPT(6))614,615,614
  614 LSIZE=MSIZE/8
      IF ((LSIZE*8).LT.MSIZE) LSIZE=LSIZE+1
  610 WRITE(LFNO, 603) CC, RUN,INCMNT,SSQ
  603 FORMAT (A1 ,20X,A40,' - CENTROID SCALAR PRODUCTS MATRIX FOR DATAS
     +ET ',I3//30X,' SUM OF SQUARES FOR ALL MATRIX VALUES EQUALS ',F15
     +.4)
      CC=DBL
C
      K1=1
      DO 1100L=1,LSIZE
      K2=K1+7
      K2=MIN0(K2,MSIZE)
      WRITE(LFNO,300) CC,INCMNT
 300  FORMAT(A1,40X,'---DATA SET ',I3)
      WRITE(LFNO, 400)  (K,K=K1,K2)
400   FORMAT('0',2X,8I14/)
      DO 110 J= 1,MSIZE
      WRITE(LFNO, 500)  J,(SMEAN(J,K),K=K1,K2)
500   FORMAT(' ',I2,8F14.3)
  110 CONTINUE
      CC=DBL
      K1=K2+1
1100  CONTINUE
C
  615 CONTINUE
      RETURN
C     DEBUG SUBCHK
      END
c
      SUBROUTINE EIGTRX(MSIZE,NSETS,INCMNT,XDIM,LABELS,NSTAR,DIM,
     +SMEAN,                  FAX,Y,Z,VT,C,ROOT,ITER,PTOT)
C
C         SUBROUTINE EIGTRIX WILL COMPUTE CHARACTERISTIC
C         ROOTS AND VECTORS OF A MATRIX OF UNSTANDARDIZED
C         VALUES USING THE ITERATIVE ADAPTATION OF THE DETERMINANT
C         METHOD SUPPLIED BY VAN DE GEER (1972).  ALL NEGATIVE
C         EIGENVALUES ARE MADE AVAILABLE TO THE USER. (THE USER
C         SHOULD NOTE THAT THIS IS AN EXACT SOLUTION.  ITERATION
C         PROVIDES A MORE RAPID AND ECONOMICAL METHOD FOR
C         DERIVING THE LATENT STRUCTURE THAN DOES POLYNOMIAL
C         EXPANSION.)
C
      IMPLICIT REAL (A-H,O-Z)
C
      CHARACTER*40 LABELS(40)
      DIMENSION SMEAN(40,40),FAX(40,40),Y(40,40),Z(40,40),
     +           VT(40),C(40),ROOT(40),ITER(40),PTOT(40)
C
      CHARACTER*5 NM,TRNS,NORM
      INTEGER BITS   ! got rid of cc Feb 24, 2013
      INTEGER PLT
      INTEGER CUTOFF      !DBG
      INTEGER TG,ST
      INTEGER TRF          !,GEN
      INTEGER ANY
      INTEGER EIG,ROT,RD
      INTEGER OPT(30),NSTAR(40,40),DIM(40),XDIM(40,40)
c      INTEGER TWO,ONE,HDR(3),BLNK      ! commented out Feb 24, 2013
      character two, one, hdr(3), blnk,cc  ! changed Feb 24, 2013
C S.D. 6-26-86  ADDED NDIMR AND NDIMI FOR PROPER
C ROTATED HEADER OUTPUT.
C
      INTEGER NDIMR(50),NDIMI(50)
C
      CHARACTER * 40 RUN
C
C SRD 6-26-86 ADDED COMMON BLOCK 'DEMEN' AND INTEGER
C ARRAYS NDIMR AND NDIMI.  FOR THE PROPER FORMATING
C OF THE ROTATED COORDINATES HEADER CARDS.
C
      COMMON/DIMEN/NDIMR,NDIMI,NDIMS
C
C
      COMMON/AMGCOM/ST,TG,MESS(4)
      COMMON/BASE/MNS,EIG,ROT,RD
      COMMON/CUTOFF/CUTOFF
      COMMON/KJOB/KJOB
      COMMON/LFN/LFNI,LFNO,LFNP
      COMMON/MAXITR/MAXITR
      COMMON/OPT/OPT
      COMMON/PLT/PLT
      COMMON/TOL/T
      COMMON/TRF/TRF
      COMMON/RUN/RUN
      DATA TWO /'2'/, BLNK/' '/, ONE/'1'/
      DATA NORM/'NORML'/
      DATA TRNS/'TRANS'/
      DATA MAXITR /500/ ! moved from block data 3/2/13 jw
      DATA T/.0001/ ! ditto jw, but used "T" instead of "TOL"
      NDIMS=NDIMS+1
C
      DO 5 K=1,MSIZE
      DO 5 L=1,MSIZE
      FAX(K,L)=0.0
      Y(K,L)=0.0
      Z(K,L)=0.0
5     CONTINUE
C
C TRANSLATE FLAG....NE.0 IF TRANSLATIONS TO BE DONE
      KFG=0
C
C CARRIAGE CONTROL VARIABLE...2 THEN 1 THEN 2  ETC.
      CC=TWO
C         READ AND/OR ARRAY SCALAR PRODUCTS MATRIX
C
      IF(OPT(2)) 600,601,600
  600 READ(LFNI,6031) HDR
 6031 FORMAT(2A4,A2)
      DO 20 I=1,MSIZE
      READ(LFNI,HDR) (SMEAN(I,J),J=1,MSIZE)
C     WRITE(6,999)MSIZE,(SMEAN(I,J),J=1,MSIZE)
   20 CONTINUE
 999  FORMAT(I5,8(F14.3))
  601 DO 150 KOUNT=1,MSIZE
C
C         QUINQUE-EXPONENTIATE THE MATRIX
C
1000     CONTINUE
      DO 14 I=1,MSIZE
      DO 14 J=1,MSIZE
      Z(I,J)=SMEAN(I,J)
14    CONTINUE
      DO 13 J=1,4
      DO 12 K=1,MSIZE
      DO 12 L=1,MSIZE
      Y(K,L)=0.0
      DO 12 M=1,MSIZE
      IF(J-1)210,205,210
205   Z(K,M)=SMEAN(K,M)
210   Y(K,L)=Y(K,L)+Z(K,M)*SMEAN(M,L)
   12 CONTINUE
      DO 13 K=1,MSIZE
      DO 13 L=1,MSIZE
      Z(K,L)=Y(K,L)
   13 CONTINUE
C
C         ITERATE TO EQUIVALENCE PRODUCT VECTORS
C
   26 DO 40 J=1,MSIZE
      VT(J)=1.0
   40 CONTINUE
      ITER(KOUNT)=1
C
C SAVE OLD TOLERANCE IN CASE OF MAXITER LIMTIT ALTERATIONS
      OLDT=T
  120 DO 50 M=1,MSIZE
      C(M)=0.0
      DO 50 N=1,MSIZE
      C(M)=C(M)+Z(M,N)*VT(N)
   50 CONTINUE
      ITER(KOUNT)=ITER(KOUNT)+1
      DIV=C(1)
      DO 60 J=2,MSIZE
      IF(ABS(C(J)).GT.ABS(DIV))DIV=C(J)
   60 CONTINUE
      IF(DIV.NE.0)GO TO 9
      WRITE(LFNO,10) INCMNT,KOUNT
   10 FORMAT('  CANNOT FACTOR SPACE ',I3,'  SUM OF ELEMENTS IN ',I3,' RO
     +W ARE 0')
      STOP
C
9     CONTINUE
      DO 70 K=1,MSIZE
      CTMP=C(K)/DIV
      IF(ABS(CTMP-VT(K))-T)70,70,90
   70 VT(K)=CTMP
      GO TO 110
   90 DO 1231 L=K ,MSIZE
      VT(L)=C(L)/DIV
 1231 CONTINUE
C
C  CHECK THE ITTERATIONS AGAINST MAXITER FOR THIS ROOT...REDUCE T IF NEE
1230  IF(ITER(KOUNT).LE.MAXITR)GO TO 120
      T=T*10.
c       print*, ' T is  ',t
      IF(T.GE.5) GO TO 4184
      WRITE(LFNO,1947) CC,KOUNT,T ! ** debug stopped writing whilst fixing...
1947  FORMAT(A3,'MAXITER REACHED ON ROOT ',I2,' TOLERANCE REDUCED TO',
     +F13.9)
      ITER(KOUNT)=1
      CC=BLNK
      GO TO 120
4184  WRITE(LFNO,4176)
4176  FORMAT('  A TOLERANCE OF 5 IS NOT NORMALLY ACCEPTABLE. '/
     +'  CHECK YOUR INPUT')
      STOP
C
C         RETRIEVE ROOT AND NORMALIZE VECTOR
C
  110 DIV=SIGN(ABS(DIV)**.2,DIV)
      ROOT(KOUNT)=DIV
      SUMC=0.0
      DO 130 K=1,MSIZE
      SUMC=SUMC+VT(K)**2
  130 CONTINUE
      P=SQRTT(SUMC)
      Q=SQRTT(DIV)
      DO 140 K=1,MSIZE
      FAX(K,KOUNT)=(VT(K)/P)*Q
  140 CONTINUE
C
C RESTORE THE TOLERANCE TO THE PARAMETER VALUE
      T=OLDT
C
C        COMPUTE RESIDUAL MATRIX
C
      SGN=1
      IF(DIV.GT.0)SGN= -SGN
      DO 150 K=1,MSIZE
      DO 150 L=1,MSIZE
      SMEAN(K,L)=SMEAN(K,L)+SGN*(FAX(K,KOUNT)*FAX(L,KOUNT))
  150 CONTINUE
C
C          SORT VECTORS FROM NATURAL TO DESCENDING ORDER
      NUML1=MSIZE-1
 4000 NDEX=0
C
      DO 3000 IXE=1,NUML1
      IF (ROOT(IXE).GE.ROOT(IXE+1)) GO TO 3000
      NDEX=1
      TMP=ROOT(IXE)
      ROOT(IXE)=ROOT(IXE+1)
      ROOT(IXE+1)=TMP
      ITMP=ITER(IXE)
      ITER(IXE)=ITER(IXE+1)
      ITER(IXE+1)=ITMP
      DO 2050 J=1,MSIZE
      TMP=FAX(J,IXE)
      FAX(J,IXE)=FAX(J,IXE+1)
 2050 FAX(J,IXE+1)=TMP
 3000 CONTINUE
      IF(NDEX.NE.0)GO TO 4000
C
C         TRANSLATE TO STABLE CENTROID SOLUTION
C
806   IF(KFG)807,811,807
807   CALL SFXLAT(MSIZE,FAX,ROOT,NSTAR)
C
C         COMPUTE CUMULATIVE PERCENTAGES OF DISTANCE
C
C KEEP RECORD OF THE 'ZERO-ROOT', AS THIS DETERMINES
C THE IMMAGINARY PART OF THE SPACE
C
  811  RMIN=ABS(ROOT(1))
      STOT=ROOT(1)
      CUTOFF=1
      DO 525 K=2,MSIZE
      STOT=STOT+ROOT(K)
      IF(ABS(ROOT(K)).GT.RMIN)GO TO 525
      RMIN=ABS(ROOT(K))
      CUTOFF=K
  525 CONTINUE
      SREAL=0
      CUTOFF=CUTOFF-1
      DO 1806 K=1,CUTOFF
      SREAL=SREAL+ROOT(K)
 1806  CONTINUE
      SIMAG=STOT-SREAL
      WARP=SREAL/STOT
      DIM(INCMNT)=CUTOFF
C
      DO 530 K=1,MSIZE
      PTOT(K)=     ABS  ((ROOT(K)/STOT)*100.0)
  530 CONTINUE
C
      DO 64 I=1,CUTOFF
      VT(I)=ABS(ROOT(I)/SREAL*100.)
  64  CONTINUE
      IF(CUTOFF+1.GT.MSIZE)GO TO 65
      ICT=CUTOFF+1
      DO 66 I=ICT,MSIZE
      VT(I)=ABS(ROOT(I)/SIMAG*100.)
   66 CONTINUE
  65  CONTINUE
C
C         STORE AND OUTPUT COORDINATE MATRIX
C
      IF(KFG)907,9100,907
 9100 CONTINUE
C
C FIRST TIME THROUGH  (NORMAL)
C SET THE CHECK BIT FOR THE OUTPUT ROUTINE
C SETUP THE NAME FOR THE PUNCH LABEL
C STORE ON THE FILE ONLY IF NO TRANSLATION IS REQUIRED (TRF=0)
      BITS=8
      NM=NORM
      IF(TRF.EQ.0)CALL PUT(EIG+INCMNT,MSIZE,FAX)
      GO TO 9111
C
  907 CONTINUE
C
C SECOND TIME THROUGH  (TRANSLATED)
C SET THE CHECK BIT AS BEFORE
C SETUP THE NAME AS BEFORE
C STORE IS MANDATORY AT THIS POINT  (TRF NOT CONSIDERED)
      BITS=10
      NM=TRNS
      CALL PUT(EIG+INCMNT,MSIZE,FAX)
 9111 CONTINUE
C
C
C IF EITHER EIGENVECTORS OR EIGEN- VALUES ARE TO BE PRINTED, ANY'0
      ANY=OPT(BITS)+OPT(BITS+20)
610   LSIZE=MSIZE/8
      IF(LSIZE*8.NE.MSIZE)LSIZE=LSIZE+1
       CC=ONE
      KA=1
      IF(ANY.EQ.0)GO TO 6789
C
      DO 300 L=1,LSIZE
      KB=KA+7
      KB=MIN0(KB,MSIZE)
      call prntcon(12,lfno)
      WRITE(LFNO,500) MSIZE,INCMNT
  500 FORMAT (25X,' Galileo Coordinates of ',I2,' Variables in Riema
     +nn Space for Data Set ',I3/)
C
      IF(KFG)2,6,2
6     WRITE(LFNO,4)
4     FORMAT(60X,'Normal Solution')
      GO TO 7
2     WRITE(LFNO,8)
8     FORMAT(44X,'SOLUTION TRANSLATED TO STABLE CONCEPTS CENTRIOD')
7     CONTINUE
C
      WRITE(LFNO, 250)  (M,M=KA,KB)
250   FORMAT('0',14X,8I14/)
C
      IF(OPT(BITS).EQ.0) GO TO 433
      DO 301 J=1,MSIZE
C RZ THIS LINE ORIGINALLY READ   LABELS(J,1) AND LABELS(J,2)
C     WRITE(LFNO, 62)  J,LABELS(J),LABELS(J),(FAX(J,K),K=KA,KB)
C62   FORMAT(' ',I2,2X,2A4,2X,8F14.3)
      write(lfno,62) j,labels(j),(fax(j,k),k=ka,kb)
   62 format (' ',i2,2x,a8,2x,8f14.3)
  301 CONTINUE
  433 CONTINUE
      IF(OPT(BITS+20).EQ.0) GO TO 678
      WRITE(LFNO, 61)  (ROOT(K),K=KA,KB)
   61 FORMAT (/' ',6X,'Eigenvalues (roots) of eigenvector matrix-- '/
     +15X,8F14.3)
C
C67    WRITE(LFNO, 63) (ITER(K),K=KA,KB)
   63 FORMAT (/' ',5X,' NUMBER OF ITERATIONS TO DERIVE THE ROOT-- '/
     +15X,8I14)
      WRITE(LFNO,554) (PTOT(K),K=KA,KB)
554   FORMAT(/1X,6X,'Percentage of variance accounted for by '
     +,'individual factors-'/15X,8F14.3)
      WRITE(LFNO,876) (VT(K),K=KA,KB)
876   FORMAT(/1X,6X,'Percentage of variance accounted for by '
     +,'individual factors in their own spaces-'/15X,8F14.3)
      WRITE(LFNO,432) STOT,WARP
 432  FORMAT(/16X,'Sum of Roots ',F14.3,10X,
     +'*********  WARP FACTOR = ',F10.4,' **********')
      IF(WARP.LE.2.0)GO TO 100
      WRITE(6,101)
  101 FORMAT(10X,'Beam me up, Scotty!')
  100 continue
C
      WRITE(LFNO,6720) CUTOFF
 6720 FORMAT(/16X,'  Number of dimensions in real space ',I2)
      MC1=MSIZE-CUTOFF
      NDIMI(NDIMS)=MC1
      NDIMR(NDIMS)=CUTOFF
      WRITE(LFNO,6721) MC1
 6721 FORMAT(/16X,'  Number of dimensions in imaginary space ',I2)
 678  CONTINUE
      CC=TWO
      KA=KB+1
  300 CONTINUE
C
C         PUNCH MATRICES
 6789 CONTINUE
      IF(OPT(BITS+1).EQ.0) GO TO 1417
      WRITE(LFNP, 334) MSIZE,CUTOFF,CUTOFF+MC1,RUN,NM,NSETS
  334 FORMAT('(6F12.4)  ',3I3,A40,3X,A5,'Set',I3)
      DO 400 K=1,MSIZE
      WRITE(LFNP, 270)  (FAX(K,J),J=1,MSIZE)
  270 FORMAT (6F12.4)
  400 CONTINUE
C
1417  CONTINUE
C
C CALL REGENERATOR OF DISTANCES IF REQUIRED
      IF(OPT(BITS+11).EQ.0) GO TO 611
      CALL REGEN(FAX,CUTOFF,MSIZE,Z)
611   CONTINUE
C
C CHECK AND CALL THE AUTOMATIC MESSAGE GENERATER (AMG)
      IF(KFG.NE.0)RETURN
      IF(MESS(1).LE.0)GO TO 7014
      CALL AMG(FAX,MSIZE,CUTOFF,VT,C,ROOT,LABELS)
7014  CONTINUE
C
C ON SECOND TIME THROUGH, LEAVE...
C
      IF(TRF.EQ.0)RETURN
C IF ZERO, NO TRANSLATE...RETURN
C IF NOT, TRANSLATE AND STORE
      KFG=1
      GO TO 806
C     DEBUG SUBCHK
      END
c
      SUBROUTINE AMG(COORD,MSIZE,NR,VEC1,VEC2,VECS,LABELS)
C
C   THIS IS THE AUTOMATIC MESSAGE GENERATOR...A M G  FOR SHORT
C MAKES IT POSSIBLE TO GENERATE MESSAGES FOR 1,2,3, OR 4 PAIR MESSAGE F
C SOLUTIONS...
      COMMON/AMGCOM/ST,TG,MESS(4)
      COMMON/LINEC/LINEC
C      IMPLICIT REAL (A-H,O-Z)
      DIMENSION COORD(40,40), VEC1(40), VEC2(40),VECS(40),rleft(10)
      INTEGER ST,TG,cons(10,4)
      CHARACTER*1 LABL(11)
      character*11 labls2(10)
      CHARACTER*40 LABELS(40)
      real best2(10)
      common/besmes/cons,rleft,best2,labls2      !  moved rleft, cons Feb 24, 2013
      DATA BEST2 /10*100./
C      data(best2(i),i=1,10)/100.00,100.00,100.00,100.00,100.00,100.00
C     +,100.00,100.00,100.00,100.00/
      open(unit=10,status='unknown')
C
C     WRITE(6,977)((COORD(L,M),M=1,MSIZE),L=1,MSIZE)
  977 FORMAT(3X,12F10.3)
      NR1=NR+1
      IF(NR1.GT.MSIZE)NR1=-1
      DO 1 I=1,MSIZE
      CON=COORD(ST,I)
      VECS(I)= CON
      DO 1 J=1,MSIZE
      COORD(J,I)=COORD(J,I)-CON
    1 CONTINUE
    2 CONTINUE
C
C  CALCULATE THE LENGTH AND FORM OF THE TARGET VECTOR
      TGLN=0.
      DO 3 I=1,NR
      VEC1(I)=COORD(TG,I)
      TGLN=TGLN+VEC1(I)**2
    3 CONTINUE
      IF(NR1.LT.0)GO TO 4
      DO 5 I=NR1,MSIZE
      VEC1(I)=COORD(TG,I)
      TGLN=TGLN-VEC1(I)**2
    5 CONTINUE
C
    4 TGLN=SQRTT(TGLN)
C
C BEGIN CHECKING THE BITS OF MESS
C
      IF(MESS(1)) 6,7,6
    6 LINEC=76
      DO 8 I=1,MSIZE
       IF(I .EQ. TG)GO TO 8
      DO 9 J=1,MSIZE
      VEC2(J)=COORD(I,J)
    9 CONTINUE
      CALL LABMAK(1,I,J,K,L,LABL)
      CALL AMGSUB(VEC1,VEC2,MSIZE,NR,NR1,TGLN,'  1-','PAIR',LABL
     +,I,J,K,L)
    8 CONTINUE
C
7     IF(MESS(2)) 10,11,10
   10 MS1=MSIZE-1
      LINEC=76
      DO 12 I=1,MS1
       IF(I .EQ. TG )GO TO 12
      II=I+1
      DO 13 J=II,MSIZE
       IF(J .EQ. TG )GO TO 13
C
C WORKING WITH THE I-J PAIR MESSAGE
      DO 14 K=1,MSIZE
      VEC2(K)=(COORD(I,K)+COORD(J,K))/2.
   14 CONTINUE
      CALL LABMAK(2,I,J,K,L,LABL)
      CALL AMGSUB(VEC1,VEC2,MSIZE,NR,NR1,TGLN,'  2-','PAIR' ,LABL
     +,I,J,K,L)
   13 CONTINUE
   12 CONTINUE
C
11    IF(MESS(3))27,15,27
   27 MS1=MSIZE-1
      MS2=MS1-1
      LINEC=76
      DO 16 I=1,MS2
       IF(I .EQ. TG)GO TO 16
      II=I+1
      DO 17 J=II,MS1
       IF(J .EQ. TG )GO TO 17
      JJ=J+1
      DO 18 K=JJ,MSIZE
       IF(K .EQ. TG )GO TO 18
C
C  WORKING WITH THE I-J-K PAIR MESSAGE
      DO 19 L=1,MSIZE
      VEC2(L)=(COORD(I,L)+COORD(J,L)+COORD(K,L))/3.
   19 CONTINUE
      CALL LABMAK(3,I,J,K,L,LABL)
      CALL AMGSUB(VEC1,VEC2,MSIZE,NR,NR1,TGLN,'  3-','PAIR',LABL
     +,I,J,K,L)
   18 CONTINUE
   17 CONTINUE
   16 CONTINUE
C
15    IF(MESS(4)) 20,21,20
   20 MS1=MSIZE-1
      MS2=MS1-1
      MS3=MS2-1
      LINEC=76
      DO 22 I=1,MS3
       IF(I .EQ. TG )GO TO 22
      II=I+1
      DO 23 J=II,MS2
       IF(J .EQ. TG)GO TO 23
      JJ=J+1
      DO 50 K=JJ,MS1
       IF(K .EQ. TG)GO TO 50
      KK=K+1
      DO 25 L=KK,MSIZE
       IF(L .EQ. TG )GO TO 25
C
C WORKING WITH THE I-J-K-L PAIR MESSAGE
      DO 26 M=1,MSIZE
      VEC2(M)=(COORD(I,M)+COORD(J,M)+COORD(K,M)+COORD(L,M))/4.
   26 CONTINUE
      CALL LABMAK(4,I,J,K,L,LABL)
      CALL AMGSUB(VEC1,VEC2,MSIZE,NR,NR1,TGLN, '  4-','PAIR',LABL
     +,I,J,K,L)
   25 CONTINUE
   50 CONTINUE
   23 CONTINUE
   22 CONTINUE
C
C
C     RESTORE THE MATRIX
21    DO 29 I=1,MSIZE
      CON = VECS(I)
      DO 29 J=1,MSIZE
      COORD(I,J) = COORD(I,J) + CON
29    CONTINUE
      write(6,1236)
 1236 format(///'0 And the winners are.....'////)
      WRITE(6,1239)
 1239 FORMAT(' Message',5x,'Concepts',17X,'% Remaining',
     +5X,'Distance Remaining')
      PRINT*,' '
      DO 1234 II=1,10
        WRITE(6,1235)II,labels(cons(ii,1)),bEST2(II),RLEFT(II)
        DO 413 NIG=2,4
  413   write(6,1237)LABELS(CONS(II,NIG))
 1237   format(12x,a20)
 1234   BEST2(II)=100.0
      close(10)
 1235 FORMAT(/5X,I2,5x,A20,7x,F6.2,15x,F8.2)
c      CALL XERROR ! Xerror disabled until we verify it - jw 11/20/87
      RETURN
C     DEBUG SUBCHK
      END
C
      SUBROUTINE XERROR
      common/besmes/rleft,best2,labls2   ! moved rleft Feb 24, 2013
      COMMON/STATI/AVEERR,MNC
      character*11 labls2(10)
      character*1 test1,test2,ast
      real best2(10),rleft(10),dif
      data t1/1.0/,t2/1.96/,ast/'*'/
      TST1=AVEERR*T1
      TST2=AVEERR*T2
      PRINT*,' '
      PRINT*,' '
      PRINT*,' '
      PRINT*, 'Ave Standard Error ',aveerr
      PRINT*,' '
      write(6,99)
   99 FORMAT('0 MESS PAIR ',10X,'DIFF.',5X,' .68 ',
     +5X,' .95 '/)
      do 10 i=1,10
      do 9,j=1,10
      IF(I.LE.J)GOTO9
      DIF=RLEFT(J)-RLEFT(I)
      IF(DIF.GE.TST1)THEN
      TEST1=AST
      RNM=1.0
      ELSE
       TEST1=' '
      END IF
      IF(DIF.GE.TST2)THEN
      TEST2=AST
      ELSE
      TEST2=' '
      END IF
      IF(TEST1.EQ.AST)THEN
      WRITE(6,100)I,J,DIF,TEST1,TEST2
  100 FORMAT(3X,I2,',',I2,8X,F10.2,9X,A1,9X,A1)
      END IF
    9 CONTINUE
   10 CONTINUE
      PRINT*, ' '
      PRINT*,' '
      IF(RNM.EQ.1.0)RETURN
      PRINT*,' There were no significant differences reported.'
      RETURN
      END
c
      SUBROUTINE AMGSUB(TG,RES,MSIZE,NR,NR1,STTG,TITL,TITL1,LAB
     +,n1,n2,n3,n4)
      IMPLICIT REAL (A-H,O-Z)
C
C THE WORK HORSE FO THE AMG
C
      DIMENSION TG(40),RES(40)
      INTEGER CNT
      CHARACTER*4 TITL,TITL1
      CHARACTER*1 LAB(11)
      COMMON/LINEC/CNT
      COMMON/AMGCOM/IST,ITG,IMESS(4)
      COMMON/LFN/LFNI,LFNO,LFNP
      COMMON/AP/AP
      COMMON/STATI/AVEERR,MNC
C
      theter = -1.0
      SCP =0.
      STR=0.
      TGR=0.
C
C VARIABLES ARE DEFINED AS FOLLOWS:
C SCP IS A SCALAR PRODUCT
C THETA IS THE ANGLE BETWEEN THE TARGET VECTOR AND THE START VECTOR
C STR IS THE START TO RESULTANT LENGTH OR THE LENGTH OF THE RESULTANT
C TGR IS THE DISTANCE FROM YHE TARGET TO THE RESULTANT (ENDPOINT OR CONC
C TGCAP IS THE TARGET TO CLOSEST APPROACH POINT DISTANCE
C STCAP IS THE START TO C. A. P. DISTANCE
C ONLY THE LENGTH OF THE RESULTANT IS CALCULATED DIRECTLY.  OTHER THINGS
C ARE DERIVED FROM THE LAW OF SINS AND OTHER ROUTINES
C
      DO 1 I=1,NR
      SCP=SCP+TG(I)*RES(I)
      STR=STR+RES(I)**2
      TGR=TGR+(RES(I)-TG(I))**2
    1 CONTINUE
      IF(NR1.LT.0)GO TO 2
      DO 3 I=NR1,MSIZE
      SCP=SCP-TG(I)*RES(I)
      STR=STR-RES(I)**2
      TGR=TGR-(RES(I)-TG(I))**2
    3 CONTINUE
C
    2 TGR=SQRTT(TGR)
      STR=SQRTT(STR)
      IF(STTG.EQ.0.OR.STR.EQ.0)GO TO 100
      COR=SCP/(STTG*STR)
      GO TO 101
  100 COR=1.0
  101 CONTINUE
C CHECK FOR UNBOUNDED CORELATION DUE TO TRIANGULAR INEQUALITIES
C      IF(ABS(COR).GT.1.0)COR=ABS(2.0 - COR)
C RICK AND I DISAGREE ABOUT THIS...I'VE REMOVED IT 10/11/85
C
C CHECK AGAINST THE AP CRITERION
      IF(AP-1)8,8,9
8     IF(TGR/STTG.GT.AP)RETURN
      GO TO 10
9     IF(TGR/STTG.LE.AP)RETURN
10    CONTINUE
C   Correlation >1 and < -1 are taken care of here...
C   Percentage moved is printed and '-1' for angle...
C   Mark L. 8/13/86
      IF(ABS(COR).GT.1.0)then
      if(cnt.lt.75)go to 213
      cnt=4
      go to 135
  213 cnt=cnt+1
      IF(STTG.EQ.0)GO TO 1000
  135 PCT=(TGR/STTG)*100.
      GO TO 1001
1000  PCT=0.0
1001  CONTINUE
      WRITE(LFNO,107)LAB,PCT
  107 format(1x,11a1,9X,'i',5X,F8.2)
      RLFT=STTG-TGR
      call bess2(lab,pct,tgr,n1,n2,n3,n4)
c      CALL BESS(LAB,PCT,tgr,n1,n2,n3,n4) !Changed fro RLFT jw 11/30/87
      RETURN
      endif
      THETA=ACOS(COR)
      TGCAP=STTG*SIN(THETA)
      STCAP=STTG*SIN(1.570796-THETA)
      PCT=(TGR/STTG)*100.
      THETA=THETA*57.29578
C
      IF(CNT.LT.75)GO TO 4
      CNT=4
      call prntcon(12,lfno)
      WRITE(LFNO,5) TITL,TITL1,IST,ITG,STTG
    5 FORMAT(10X,'A. M. G.  ',2A4,' Message Solutions'/
     +31X,'Start IS ',I2,10X,'Target is ',I2,10X,'Distance to Target is'
     +,F8.2/)
      WRITE(LFNO,6)
    6 FORMAT(19X,'THETA',7X,'CORR.',9X,'ST-R',9X,'TG-R',8X,'TG-CAP',8X,'
     +ST-CAP',10X,'PCT')
C   6 FORMAT (18X,'THETA',8X,'PCT')
C
    4 CNT=CNT+1
      WRITE(LFNO,7) LAB,THETA,COR,STR,TGR,TGCAP,STCAP,PCT
   7  FORMAT(1X,11A1,5X,F5.1,5X,F7.3,5X,F8.2,5X,F8.2,6X,F8.2,6X,F8.2,
     +5X,F8.2)
C     WRITE(LFNO,7) LAB,THETA,PCT
C   7 FORMAT(1X,11A1,5X,F5.1,5X,F8.2)
C
C SRD  MESS
C
      rlft=tgr
      call bess2(lab,pct,rlft,n1,n2,n3,n4)
c      call bess(lab,pct,rlft)
C
C
      RETURN
C     DEBUG SUBCHK
      END
C
C
C SRD 8-12-86 10 BEST MESSAGE GENERATOR
C
      subroutine bess(lab,pct,rlft)
      character*11 labls2(10),tlabl
      character*1 lab(11)
      real best2(10),rleft(10)
      common/besmes/rleft,best2,labls2   ! moved rleft Feb. 24, 2013
      COMMON/STATI/AVEERR,MNC
      real=abs(pct)
      if(real.gt.best2(10))return
      if(real.eq.0)return
      best2(10)=real
      rleft(10)=rlft
C
      do 11 jj=1,11
   11 labls2(10)(jj:jj)=lab(jj)
      do 10 j=10,2,-1
      if(best2(j).ge.best2(j-1))return
      rt=best2(j)
      best2(j)=best2(j-1)
      best2(j-1)=rt
      tlabl=labls2(j)
      labls2(j)=labls2(j-1)
      labls2(j-1)=tlabl
      rt=rleft(j)
      rleft(j)=rleft(j-1)
      rleft(j-1)=rt
   10 continue
      return
      end
c
      SUBROUTINE NMBR(LAB,HERE,THING)
C
C FREE-FORMAT I/O ROUTNES IN FORTRAN ARE A PAIN
C
      INTEGER HERE,THING,FD,SD
      CHARACTER*1 LAB(11),DIGIT(10)
      DATA DIGIT/'0','1','2','3','4','5','6','7','8','9'/
C
      IF(THING-10)1,2,3
2     FD=2
      SD=1
      GO TO 4
C
1     FD=1
      SD=THING+1
      GO TO 4
C
3     FD=THING/10
      SD=THING-FD*10
      FD=FD+1
      SD=SD+1
C
4     LAB(HERE)=DIGIT(FD)
      LAB(HERE+1)=DIGIT(SD)
      RETURN
C     DEBUG SUBCHK
      END
c
         SUBROUTINE ROTIT(MSIZE,NSETS,DIM,XDIM,MAT,MAT1,
     +MAT2,MAT3,V1,V2,LABELS,NSTAR)
C
C THIS IS A PART OF THE ROTATER
C
         IMPLICIT REAL(A-H,O-Z)
         REAL MAT(40,40),MAT1(40,40),V1(40),V2(40),
     +MAT2(40,40),MAT3(40,40)
         INTEGER EIG,RD,ROT
      CHARACTER*40 LABELS(40)
      INTEGER OPT(30),XDIM(40,40),NSTAR(40,40),DIM(40)
      INTEGER NDIMR(50),NDIMI(50)
      CHARACTER*10 FORM
C SRD 6-26-86 ADDED COMMON BLOCK DEMEN AND
C INTEGER ARRAYS NDIMR AND NDIMI TO PROPERLY
C FORMAT ROTATED COORDINATE OUTPUT
C
      COMMON/DIMEN/NDIMR,NDIMI,NDIMS
         COMMON/OPT/OPT
         COMMON/BASE/MNS,EIG,ROT,RD
         COMMON/LFN/LFNI,LFNO,LFNP
         COMMON/MRMI/MR,MI
         COMMON/PCT/PCT
C
         IF(OPT(3))1,2,1
C
C HERE MUST READ IN THE COORDINATE MATRICIES FROM INPUT
1        DO 3 I=1,NSETS
      READ(LFNI,4) FORM,MCS,DIM(I),ndims
4	 FORMAT(A10,3I3)
         DO 5 J=1,MSIZE
	 READ(LFNI,FORM) (MAT(J,KJ),KJ=1,ndims)
5        CONTINUE
      CALL SFXLAT(MSIZE,MAT,V1,NSTAR)
         CALL PUT(EIG+I,MSIZE,MAT)
C
C CALCULATE THE PERCENT WORDS IF DELPCT CALLED
         IF(PCT)8,8,9
8        DO 10 L=1,MSIZE
	 DO 10 M=1,ndims
         XDIM(L,M)=0
10    CONTINUE
         GO TO 3
C
9        SSQ=0.
         DO 11 L=1,MSIZE
         V1(L)=0.
	 DO 12 M=1,ndims
         V1(L)=V1(L)+MAT(M,L)**2
12    CONTINUE
         SSQ=SSQ+V1(L)
11       CONTINUE
C
         DO 13 L=1,MSIZE
         IF((V1(L)/SSQ*100.)-PCT)14,14,15
14       XDIM(I,L)=1
         GO TO 13
15       XDIM(I,L)=0
13       CONTINUE
3        CONTINUE
C
C GO THROUGH THE DIM WORDS TO DECIDE IF
    2 CONTINUE
C SPACS NEED AUGMENTATION OR NOT
C     WRITE(6,100)(DIM(L),L=1,NSETS)
C
C SRD 6-26-86 USED TO DEBUG THIS MOTHER.
C
C     WRITE(9,101)(DIM(I),L=1,NSETS)
C     WRITE(9,102)(NDIMR(K),K=1,NSETS)
C     WRITE(9,103)(NDIMI(K),K=1,NSETS)
  100 FORMAT('            DIM(L)   ',10I10)
C 101 FORMAT('            DIM(I)   ',10I10)
C 102 FORMAT('            NDIMR   ',10I10)
C 103 FORMAT('            NDIMI   ',10I10)
      MIN=57
         MAX=-1
         DO 6 I=1,NSETS
         IF(DIM(I).GT.MAX) MAX=DIM(I)
         IF(DIM(I).LT.MIN) MIN=DIM(I)
6        CONTINUE
C     WRITE(6,911) MAX,MIN
  911 FORMAT('     MAX =', I7,'  MIN=', I7)
      MR=MAX
      MI=MSIZE-MIN
         IF(MAX.EQ.MIN)GO TO 7
C      WRITE(6,920)MR,MI,MSIZE,NSETS
C  920 FORMAT(4(2X,I5))
C
C SPACES ARE NOT CONFORMABLE
C AUGMENT THEM
         CALL AUGMNT(MSIZE,NSETS,MAT,MAT1,DIM,XDIM)
      IND=ROT
      GO TO 700
C
C NO AUGMENT NEEDED...NOW TO ROTATE
7     IND=EIG
  700 CALL COMROT(MSIZE,NSETS,XDIM,LABELS,NSTAR,
     +DIM,MAT,MAT1,MAT2,V1,V2,IND,MAT3)
         RETURN
C     DEBUG SUBCHK
         END
c
      SUBROUTINE AUGMNT(MS,NS,OLD,NEW,DIM,XDIM)
      IMPLICIT REAL (A-H,O-Z)
C
C THE ROUTINE THAT AUGMNTS SPACES WITH ZERO VECTORS TO MAKE THEN
C................CONFORMABLE SPACES..................
      COMMON/MRMI/MR,MI
      COMMON/BASE/MNS,EIG,ROT,RD
      REAL OLD(40,40),NEW(40,40)
      INTEGER ROT,RD,EIG,OCL
      INTEGER FR,TO,DI,ND
      INTEGER DIM(40),XDIM(40,40)
C
C OCL IS THE COLUMN OFFSET BETWEEN THE SPACE AND ITS AUGMNTATION
      ND=MR+MI
      OCL=ND-MS
      DO 100 II=1,NS
      CALL GET(EIG+II,MS,OLD)
C
C STEP1:  TRANSFER REAL PART AND ZERO ROOT FROM OLD TO NEW
      DI=DIM(II)
      DO 1 I=1,DI
      DO 1 J=1,MS
      NEW(J,I)=OLD(J,I)
    1 CONTINUE
C
C STEP2:  TRANSFER IMMAGINARY PART FROM OLD TO NEW  (IFF ANY)
      FR=DI+1
      IF(FR.GT.MS)GO TO 5
      DO 2 I=FR,MS
      DO 2 J=1,MS
      NEW(J,I+OCL)=OLD(J,I)
    2 CONTINUE
C
C STEP3:  PUT ZERO'S EVERYWHERE ELSE IN THE MATRIX
C         PART A:  COLUMNS BETWEEN DI+1 AND (FR+OCL)-1
C         PART B:  ROWS FROM MS+1 TO ND TO MAKE THE MATRIX SQUARE AGAIN
    5 TO=FR+OCL-1
      FR=DI+1
      DO 3 I=FR,TO
      DO 3 J=1,MS
      NEW(J,I)=0.
    3 CONTINUE
C
      FR=MS+1
      DO 4 I=FR,ND
      DO 4 J=1,ND
      NEW(I,J)=0.
    4 CONTINUE
C
C STEP4:  WRITE THE SPACE TO ITS PLACE AND CONTINUE THROUGH NSETS
      CALL PUT(ROT+II,ND,NEW)
  100 CONTINUE
      RETURN
C     DEBUG SUBCHK
      END
c
      SUBROUTINE COMROT(MSIZE,NSETS,XDIM,LABELS,NSTAR,DIM,CSPACE,
     +PSPACE,SAVE,VEC1,VEC2,IND,EXR)
      IMPLICIT REAL (A-H,O-Z)
C
C         SUBROUTINE COMPARE WILL PROVIDE COORDINATES OF SPACES
C         ROTATED TO LEAST SQUARES CRITERIA
C
      DIMENSION SAVE(40,40),CSPACE(40,40),
     +PSPACE(40,40),VEC1(40),VEC2(40),EXR(40,40)
      CHARACTER*40 LABELS(40)
C
      INTEGER NDIMR(50),NDIMI(50)
      INTEGER PLT
      INTEGER ST,TG,XCOR,GEN
C
      INTEGER EIG,ROT,RD,DUMMY
C     INTEGER XCOR
      INTEGER UNMASS
      INTEGER XDIM(40,40),NSTAR(40,40),OPT,DIM(MSIZE)
      CHARACTER * 40 RUN
C
C SRD 6-26-86 ADDED COMMON BLOCK DIMEN AND INTEGER
C ARRAYS NDIMR AND NDIMI. THE ARRAYS HOLD THE
C # OF DIMENSIONS IN REAL AND IMAGINARY SPACE
C FOR EACH SPACE.
      COMMON/DIMEN/NDIMR,NDIMI,NDIMS
C
C
      COMMON/PLT/PLT
      COMMON/UNMASS/UNMASS
      COMMON/RUN/RUN
      COMMON/OPT/OPT(30)
      COMMON/MRMI/MR,MI
      COMMON/LFN/LFNI,LFNO,LFNP
      COMMON/AMGCOM/ST,TG,MESS(4)
      COMMON/MSG/MSG(4)
      COMMON/MAINT/MAINV
      COMMON/MIDDLE/MIDDLE
      COMMON/BASE/MNS,EIG,ROT,RD
C
C
C
C SRD 6-26-86 OKAY HERE IT GOES.  TAKE THE LARGEST
C # OF REAL DIMENSIONS AND THE LARGEST NUMBER OF
C IMAGINARY DIMENSIONS AND ADD EM UP..
C
      DO 445 I=1,NDIMS
      NREAL=MAX(NDIMR(I),NREAL)
      NIMAG=MAX(NDIMI(I),NIMAG)
  445 CONTINUE
      NTOT=NREAL+NIMAG
C
C
C
      NIMAG=MAX(NDIMI(I),NDIMI(I+1))
C         SET PARAMETERS AND INPUT TARGET MATRIX
C
C
C MAKE GEN BIT 21 OF OPT
      GEN=OPT(21)
C
      NDIM=MR+MI
      IF(MAINV)412,412,411
412   IST=2
      JOUNT=1
      GO TO 413
411   IST=1
      JOUNT=MAINV
413   CONTINUE
C
C MAKE XCOR BITS 15 AND 16 OF OPT
      XCOR=OPT(15)+OPT(16)
      CALL GET(IND+JOUNT,IVARD,CSPACE)
      IF(OPT(12).EQ.0)GO TO 747
      CALL PR(NDIM,CSPACE,LABELS,JOUNT)
C
 747  IF(GEN.NE.0)CALL REGEN(CSPACE,MR,MSIZE,EXR)
C
      IF(OPT(13).EQ.0)GO TO 1941
      IPTK=1
C**************
C**************
C SRD CHANGED WRITE STATEMENT TO ACCOMADATE NEW
C PARAAMETERS NREAL, NTOT.
C
C     WRITE(LFNP,7717) MSIZE,NR,NDIM,RUN,IND
c      WRITE(LFNP,7717) MSIZE,NREAL,NTOT,RUN
      WRITE(LFNP,7717) MSIZE,mr,Ndim,RUN,jount ! watch this one **

C
C DEBUG
C      WRITE(9,99909)MSIZE,MR,MI,NDIM,NR
C99909 FORMAT('MSIZE=',I2,2X,'MR=',I2,2X,'MI=',I2,2X,
C    +'NDIM=',I2,2X,'NR=',I2)
C END DEBUG
C
C
C S.D. 6-25-86
C
C  CHANGED TO DROP 'Set'.  Add it in with splitcrds.
C
7717  FORMAT('(8F10.4)  ',3I3,A40,' Set'
     +, I4)
C7717  FORMAT('(8F10.4)  ',3I3,A40)
C
C***************
C****************
      NKOUNT=NKOUNT+1
      DO 1747 J=1,MSIZE
      WRITE(LFNP,91) (CSPACE(J,K),K=1,NDIM)
91    FORMAT(8F10.4)
1747  CONTINUE
C
C         INPUT MATRIX TO BE ROTATED
C
 1941 CONTINUE
      MIFR=MR+1
      DO 20 KOUNT=IST,NSETS
      IF(KOUNT.EQ.MAINV)GO TO 20
      CALL GET(IND+KOUNT,IVARD,PSPACE)
C
C         CALL ROTATE-- LEAST SQUARES ALGORITHM
C
      CALL ROTATE(CSPACE,JOUNT,PSPACE,KOUNT,NDIM,NSETS,
     +NSTAR,XDIM,1,SAVE)
      IF (IABS(DIM(KOUNT) - MSIZE) .LE. 1) GO TO 416
      CALL ROTATE(CSPACE,JOUNT,PSPACE,KOUNT,NDIM,NSETS,
     +NSTAR,XDIM,0,SAVE)
416   CONTINUE
      CALL PUT(KOUNT+ROT,DUMMY,PSPACE)
C
C         OUTPUT ROTATED SPACE
C
      IF(OPT(12).EQ.0)GO TO 1942
      CALL PR(NDIM,PSPACE,LABELS,KOUNT)
C
1942  IF(OPT(13).EQ.0)GO TO 1943
C
C  ****
C  ****
C S.D. 6-25-86
C CHANGED WRITE STATEMENT TO ACCOMADATE NREAL AND NTOT
C
C     WRITE(LFNP, 7717) MSIZE,DIM(KOUNT),RUN,KOUNT
      WRITE(LFNP, 7717) MSIZE,mr,Ndim,RUN,KOUNT
C
C DEBUG
C     WRITE(9,99909)MSIZE,MR,MI,NDIM,NR
C END DEBUG
      DO 713 J=1,MSIZE
      WRITE(LFNP, 91) (PSPACE(J,K),K=1,NDIM)
713   CONTINUE
680   CONTINUE
C
C         COMPUTE AND PRINT INTERVALS OF CHANGE
C
1943  IF(OPT(14).EQ.0)GO TO 1944
      WRITE(LFNO, 14)  JOUNT,KOUNT
   14 FORMAT ('2',35X,'Distances moved in the interval between time ',I2
     +,' and time ',I2////////)
      DIST=0.0
      DO 15 J=1,MSIZE
      SUMP=0.0
      DO 16 K=1,MR
      PYTH=((CSPACE(J,K)-PSPACE(J,K))**2)
      SUMP=SUMP+PYTH
   16 CONTINUE
C
      DO 401  K=MIFR,NDIM
      SUMP=SUMP-(CSPACE(J,K)-PSPACE(J,K))**2
401   CONTINUE
C
      THAG=SQRTT(SUMP)
      IF (THAG.LT.0) THEN
      THAG= ABS(THAG)
      WRITE(LFNO, 17)  J,LABELS(J),THAG
17    FORMAT(' ',10X,'Concept ',I2,' (',A40,') moved ',F10.3,'i',
     +' units.')
      ELSE
      WRITE(LFNO, 37)  J,LABELS(J),THAG
37    FORMAT(' ',10X,'Concept ',I2,' (',A40,') moved ',F10.3,
     +'  units.')
      ENDIF
      DIST=DIST+THAG
   15 CONTINUE
      DIST=DIST/MSIZE
      WRITE(LFNO, 18)  JOUNT,KOUNT,DIST
   18 FORMAT (' '//5X,'The Mean Distance Between All Points in Space '
     +,I2,' and their Counterparts in Space ',I2,' is ',F10.3)
C
 1944 CONTINUE
      IF(GEN.NE.0)CALL REGEN(PSPACE,MR,MSIZE,EXR)
      IF(XCOR.NE.0)CALL CORR(CSPACE,JOUNT,PSPACE,KOUNT,MR,MI,MSIZE)
C
C MESSAGE EFFECTIVENESS CODE
C
      IF(MESS(KOUNT).GE.0)GO TO 402
      DO 403 I=1,MSIZE
      VEC1(I)=0
      VEC2(I)=0
403   CONTINUE
      DO 404 II=1,4
      I=MSG(II)
      IF(I.LE.0)GO TO 404
C
      DO 405 J=1,MSIZE
      VEC1(J)=VEC1(J)+CSPACE(I,J)-CSPACE(ST,J)
405   CONTINUE
404   CONTINUE
C
      DO 406 I=1,MSIZE
      VEC2(I)=PSPACE(ST,I)-CSPACE(ST,I)
      VEC1(I)=VEC1(I)-CSPACE(ST,I)
406   CONTINUE
C
      AL=0
      BL=0
      SCP=0.
      DO 407 I=1,MR
      AL=AL+VEC1(I)**2
      BL=BL+VEC2(I)**2
      SCP=SCP+VEC1(I)*VEC2(I)
407   CONTINUE
C
      IF(MIFR.GT.MSIZE)GO TO 408
      DO 409 I=MIFR,MSIZE
      AL=AL-VEC1(I)**2
      BL=BL-VEC2(I)**2
      SCP=SCP-VEC1(I)*VEC2(I)
409   CONTINUE
C
408   AL=SQRTT(AL)
      BL=SQRTT(BL)
      COR=SCP/(AL*BL)
      ANG=1.E12
      IF(ABS(COR).LE.1.)ANG=ACOS(COR)*57.29578
      WRITE(LFNO, 410) MSG,AL,BL,SCP,COR,ANG
410   FORMAT('      MESSAGE EFFECTIVENESS...FOR THE MESSAGE',4I3/
     +'   LENGTH OF RESULTANT ',F12.3/
     +'   LENGTH OF START CONCEPTS MOTION ',F12.3/
     +'   SCALAR PRODUCT ',F12.2/
     +'   CORRELATION ',F12.6/
     +'   ANGLE ',F7.2)
402   CONTINUE
      IF (MAINV) 25,25,20
   25 DO 19 J=1,MSIZE
      DO 19 K=1,MSIZE
      CSPACE(J,K)=PSPACE(J,K)
   19 CONTINUE
      JOUNT=KOUNT
   20 CONTINUE
      RETURN
C     DEBUG SUBCHK
      END
c
      SUBROUTINE   PR(MSIZE,CSPACE,LABELS,ISET)
      IMPLICIT REAL (A-H,O-Z)
      COMMON/LFN/LFNI,LFNO,LFNP
      DIMENSION CSPACE(40,40)
      CHARACTER*40 LABELS(40)
      LSIZE=MSIZE/8
      IF((LSIZE*8).LT.MSIZE)LSIZE=LSIZE+1
      ICC=2
      DO 7 L=1,LSIZE
      KA=(8*(L-1))+1
      KB=KA+7
      KB=MIN0(KB,MSIZE)
      WRITE(LFNO,6) ICC,ISET
6     FORMAT(I1,35X,'The Rotated Coordinates of Space Number',I2//)
      WRITE(LFNO,90) (K,K=KA,KB)
90    FORMAT(15X,8I14)
      DO 709 J=1,MSIZE
CRZ THIS ORIGINALLY WAS  LABELS (I,1)  LABELS(I,2)
      WRITE(LFNO,701) J,LABELS(J),(CSPACE(J,K),K=KA,KB)
c     WRITE(LFNO,701) J,LABELS(J),LABELS(J),(CSPACE(J,K),K=KA,KB)
c701   FORMAT(1X,I2,2X,2A4,2X,8F14.3)
701   FORMAT(1X,I2,2X,A8,2X,8F14.3)
C
709   CONTINUE
7     CONTINUE
      RETURN
C     DEBUG SUBCHK
      END
c
      SUBROUTINE ROTATE(TARGET,KT,MATRIX,KM,MS,NS,NSTAR,XDIM,
     +HOW,SAVE)
      IMPLICIT REAL (A-H,O-Z)
C
C THIS IMPLEMENTS THE WOELFEL-HOLMES INCREMENTAL METHOD
C OF ROTATION TO LEAST-SQUARES CRITERION
C WITH STABLE CONS AND EXCLUDED DIMENSIONS
C
      DIMENSION TARGET(40,40)
      REAL MATRIX(40,40)
      INTEGER XDIM(40,40),DIM(30),NSTAR(40,40)
      INTEGER TRF
      DIMENSION SAVE(40,40)
      INTEGER HOW,FR,TO,TO1
      COMMON/MRMI/MR,MI
      COMMON/TRF/TRF
      COMMON/THINC/ANG
      COMMON/LFN/LFNI,LFNO,LFNP
      QPNOW=0
      NOW=1
      IF(TRF.GT.1)NOW=KT
      IF(HOW) 10,11,10
10    FR=1
      TO=MR
      GO TO 12
11    FR=MR+1
      TO=MS
12    TO1=TO-1
C
C
C     FACTOR FLIPPER
C
      DO 1001 I=1,MS
      CALL DIST(TARGET,MATRIX,FR,TO,MS,KT,KM,NSTAR,XDIM,NOW,D)
      DO 1002 J=1,MS
      MATRIX(J,I)=-MATRIX (J,I)
1002  CONTINUE
      CALL DIST(TARGET,MATRIX,FR,TO,MS,KT,KM,NSTAR,XDIM,NOW,D1)
      IF (D1.LT.D)GO TO 1001
      DO 1003 J=1,MS
      MATRIX(J,I)=-MATRIX(J,I)
1003  CONTINUE
1001  CONTINUE
C
C      ********** WOELFEL'S FOLLY **********
C
C
C     START ANGLE AT 8 DEGREES
      ANG=.13962634
2527  IP=0
25    IP=IP+1
      DO 13 I=FR,TO1
      II=I+1
      DO 13 J=II,TO
      ROTWAY = 1.0
      ITIME = 0
      JTIME = 0
C
15    DO 14 L=1,MS
      DO 14 M=1,MS
      SAVE(L,M)=MATRIX(L,M)
14    CONTINUE
      JTIME=JTIME+1
      IF(ITIME.EQ.1)GO TO 13
      CALL DIST(TARGET,MATRIX,FR,TO,MS,KT,KM,NSTAR,XDIM,NOW,D)
      CALL TWIST(MATRIX,I,J,MS,ROTWAY)
      CALL DIST(TARGET,MATRIX,FR,TO,MS,KT,KM,NSTAR,XDIM,NOW,D1)
      ITIME = ITIME + 1
      IF(D1.LT.D)GO TO 15
      ITIME = 0
      DO 16 L=1,MS
      DO 16 M=1,MS
      MATRIX(L,M)=SAVE(L,M)
16    CONTINUE
      IF(JTIME.EQ.2)GO TO 13
      ROTWAY = -1.0
      GO TO 15
13    CONTINUE
      QP = QPNOW
      QPNOW = D1
      IF(IP.EQ.1)GO TO 27
      IF(QPNOW-QP)27,30,30
   27 IF(IP.LT.500)GO TO 25
      WRITE(LFNO,1004)I,J
1004  FORMAT(' AFTER 500 TRIPS, NO CONVERGENCE ON FACTORS',2I3)
   30 CONTINUE
      ANG=ANG/2.0
C
      IF(ANG.GE..017453293)GO TO 2527
C
C      ********** END OF FOLLY **********
      RETURN
C     DEBUG SUBCHK
      END
c
      SUBROUTINE DIST(TAR,MAT,FR,TO,MS,KT,KM,NST,XDM,NOW,D)
      IMPLICIT REAL (A-H,O-Z)
      DIMENSION TAR(40,40),MAT(40,40)
      INTEGER FR,TO,R,C
      INTEGER XDM(40,40),NST(40,40)
      REAL MAT
C
      D=0.
      DO 1 R=1,MS
      IF(NST(R,NOW).EQ.0)GO TO 1
      DO 2 C=FR,TO
      IF(XDM(KT,C).EQ.1)GO TO 2
      IF(XDM(KM,C).EQ.1)GO TO 2
      D=D+(TAR(R,C)-MAT(R,C))**2
2     CONTINUE
1     CONTINUE
C     D=SQRTT(D)
      RETURN
C     DEBUG SUBCHK
      END
c
      SUBROUTINE TWIST(MATRIX,P,Q,M,WAY)
      IMPLICIT REAL (A-H,O-Z)
C
C THE ACTUAL ROTATION OF THE MATRIX TAKES PLACE HERE
C
      REAL MATRIX(40,40)
      INTEGER P,Q
      COMMON/THINC/ANG
      ANG=ANG*WAY
  101 SINA=SIN(ANG)
      COSA=COS(ANG)
C
C NOW, DO THE ACTUAL MATRIX ROTATION
C     AX=0
C     BX=0
      DO 3 J=1,M
      AJP=MATRIX(J,P)
      AJQ=MATRIX(J,Q)
      MATRIX(J,P)=AJP*COSA-AJQ*SINA
      MATRIX(J,Q)=AJQ*COSA+AJP*SINA
    3 CONTINUE
C     AX=AJP
C     BX=AJQ
C
    1 CONTINUE
      RETURN
C     DEBUG SUBCHK
      END
c
      SUBROUTINE SFXLAT(MSIZE,FAX,ROOT,NSTAR)
C
C STABLE-FREE CONS TRANSLATOR.  MOVED HERE FROM EIGTRX ON 10/16/80
C TO PROVIDE FOR THE TRANSLATION OF "READ-IN" COORDINATES ON THEIR
C WAY TO ROTATION.....JUST AN OVERSIGHT.
C
      IMPLICIT REAL (A-H,O-Z)
      DIMENSION FAX(40,40),ROOT(40),NSTAR(40,40)
807   DO 803 K=1,MSIZE
      F=0.0
      RTMP=0
      KSTAR=0
      DO 804 KR=1,MSIZE
      IF(NSTAR(KR,1).EQ.0)GO TO 804
      F=F+FAX(KR,K)
      KSTAR=KSTAR+1
  804 CONTINUE
      F=F/KSTAR
      DO 805 J=1,MSIZE
      FAX (J,K)=FAX(J,K)-F
      RTMP=RTMP+(FAX (J,K)**2)
  805 CONTINUE
      ROOT(K)=SIGN(RTMP,ROOT(K))
  803 CONTINUE
      RETURN
      END
c
      SUBROUTINE CORR(T1,JOUNT,T2,KOUNT,MR,MI,MS)
      IMPLICIT REAL (A-H,O-Z)
C
C ROUTINE FOR DOING CROSS-GROUP ROW AND COL. CORRELATIONS
C
      DIMENSION T1(40,40),T2(40,40)
      INTEGER OPT(30)
      COMMON/OPT/OPT
      COMMON/LFN/LFNI,LFNO,LFNP
      DATA RTOD/57.29578/
C
      MIFR=MR+1
      IF(OPT(15))1,2,1
C
C DO THE CROSS GROUP ROW CORRELATIONS
1     WRITE(LFNO,3) JOUNT,KOUNT
3     FORMAT('2','Row Vector Correlations Between Time',I2,' and Time',I
     +2)
      WRITE(LFNO,4) JOUNT,KOUNT
4     FORMAT('-',20X,'Concept',25X,'T',I2,' Magnitude',5X,'T',I2,
     +' Magnitude',5X,'Scalar Product',5X,'Correlation',5X,'Angle')
C
      DO 5 I=1,MS
      AL=0
      BL=0
      SCP=0
      DO 6 J=1,MR
      AL=AL+T1(I,J)**2
      BL=BL+T2(I,J)**2
      SCP=SCP+T1(I,J)*T2(I,J)
6     CONTINUE
C
      IF(MI.LE.0)GO TO 7
      DO 8 J=MIFR,MS
      AL=AL-T1(I,J)**2
      BL=BL-T2(I,J)**2
      SCP=SCP-T1(I,J)*T2(I,J)
8     CONTINUE
7     CONTINUE
      AL=SQRTT(AL)
      BL=SQRTT(BL)
      ALBL=AL*BL
      IF(ALBL.EQ.0)GO TO 251
      COR=SCP/(AL*BL)
      if(abs(cor).gt.1.)cor=(1-(abs(cor)-1))  !jw 11/26/87
      GO TO 261
  251 COR=1.0
  261 CONTINUE
c      ANG=1.E12 ! Can this make sense? JW/11/26/87
      ang=1.0    ! This must be it.
      IF(ABS(COR).LE.1)ANG=ACOS(COR)*RTOD
      WRITE(LFNO,9) I,AL,BL,SCP,COR,ANG
9     FORMAT(25X,I2,25X   ,F12.2,5X,F12.2,5X,F13.2,5X,F11.6,5X,F5.1)
5     CONTINUE
C
2     IF(OPT(16))10,11,10
10    WRITE(LFNO,12) JOUNT,KOUNT
12    FORMAT('2','Col Vector Correlations Between Time',I2,' and Time',I
     +2)
      WRITE(LFNO,13) JOUNT,KOUNT
13    FORMAT('-',52X,'T',I2,' Magnitude',5X,'T',I2,
     +' Magnitude',5X,'Scalar Product',5X,'Correlation',5X,
     +'Angle')
      DO 50 I=1,MS
      AL=0
      BL=0
      SCP=0
      DO 60 J=1,MS
      AL=AL+T1(J,I)**2
      BL=BL+T2(J,I)**2
      SCP=SCP+T1(J,I)*T2(J,I)
60     CONTINUE
C
C     IF(MI.LE.0)GO TO 70
C     DO 80 J=MIFR,MS
C     AL=AL-T1(J,I)**2
C     BL=BL-T2(J,I)**2
C     SCP=SCP-T1(J,I)*T2(J,I)
C 80   CONTINUE
70     CONTINUE
      AL=SQRTT(AL)
      BL=SQRTT(BL)
      ALBL=AL*BL
      IF(ALBL.EQ.0)GO TO 25
      COR=SCP/(AL*BL)
      if(abs(cor).gt.1.)cor=(1-(abs(cor)-1))  !jw 11/26/87
      GO TO 26
   25 COR=1.0
   26 CONTINUE
c      ANG=1.E12    ! as above, jw 11/26/1987
      ang=1.0       ! fixed on this day
      IF(ABS(COR).LE.1)ANG=ACOS(COR)*RTOD
      WRITE(LFNO,9) I,AL,BL,SCP,COR,ANG
50     CONTINUE
11    CONTINUE
      RETURN
C     DEBUG SUBCHK
      END
c
      SUBROUTINE REGEN(A,NR,MS,B)
C
C REGENERATES DISTANCE MATRIX FROM A SET OF COORDINATES
C
      IMPLICIT REAL (A-H,O-Z)
      DIMENSION A(40,40),B(40,40)
      CHARACTER * 40 RUN
      COMMON/RUN/RUN
      COMMON/LFN/LFNI,LFNO,LFNP
C
      MS1=MS-1
      DO 1 I=1,MS1
      IJ=I+1
      DO 1 J=IJ,MS
      SUM=0.
      DO 2 K=1,NR
      SUM=SUM+(A(I,K)-A(J,K))**2
2     CONTINUE
      IF(NR+1.GT.MS)GO TO 900
      NR1=NR+1
      DO 901 K=NR1,MS
      SUM=SUM-(A(I,K)-A(J,K))**2
901   CONTINUE
900   B(J,I)=SQRTT(SUM)
1     CONTINUE
C
      LS=MS/8
      IF((LS*8).LT.MS)LS=LS+1
C
      DO 3 L=1,LS
      K1=8*(L-1)+1
      K2=K1+7
      IF(K2.GT.MS)K2=MS
      WRITE(LFNO,4) RUN
4     FORMAT('2',35X,A40,2X,'---REGENERATED DISTANCES')
      WRITE(LFNO,5) (K,K=K1,K2)
5     FORMAT('0',3X,8I15//)
      DO 3 J=K1,MS
      K3=J
      K3=MAX0(K3,K2)
      WRITE(LFNO,6) J,(B(J,K),K=K1,K3)
6     FORMAT(2X,I2,8(1X,F14.3))
3     CONTINUE
      RETURN
C     DEBUG SUBCHK
      END
c
      SUBROUTINE AMGONL(MSIZE,NSETS,A,LABELS,V1,V2)
      IMPLICIT REAL (A-H,O-Z)
C
C INVOKES THE AMG GIVEN SETS OF COORDINATES
C IF MIDPOINT WAS OR WAS NOT USED DURING THE FORMATION
C OF THOSE COORDINATES.  THE MATRIX IS TRANSLATED TO THE START
C CONCPT IN THIS ROUTINE
C
      COMMON/OPT/OPT
      COMMON/AMGCOM/ST,TG,MESS(4)
      COMMON/LFN/LFNI,LFNO,LFNP
C
C RZ CHARACTER
      CHARACTER*10 FORM
      INTEGER ST,TG
      INTEGER OPT(30)
C
      DIMENSION A(40,40),V1(40),V2(40),DUMMYV(40)
      CHARACTER*40 LABELS(40)
C
      LSIZE=MSIZE/8
      IF((LSIZE*8).LT.MSIZE)LSIZE=LSIZE+1
C
C THE MAIN LOOP...1 THOUGH NSETS
      DO 1 INC=1,NSETS
      READ(LFNI,2) FORM,NR
C RZ CHARACTER
    2 FORMAT(A10,I2)
C
C READ IN A SET OF COORDINATES
      DO 3 J=1,MSIZE
      READ(LFNI,FORM) (A(J,K),K=1,MSIZE)
    3 CONTINUE
C
C TRANSLATE THE MATRIX TO THE START CONCPT
      DO 4 I=1,MSIZE
      CON=A(ST,I)
      DO 4 J=1,MSIZE
      A(J,I)=A(J,I)-CON
    4 CONTINUE
C
C PRINT OUT A COORDINATES SET
      IF(OPT(25).EQ.0)GO TO 705
      KA=1
       DO 660 L=1,LSIZE
      KB=KA+7
      KB=MIN0(KB,MSIZE)
      WRITE(LFNO,201) INC
  201    FORMAT('2',35X,'THE COORDINATES OF SPACE NUMBER ',I2///)
      WRITE(LFNO,90) (K,K=KA,KB)
   90 FORMAT(15X,8I4)
      DO 710 J=1,MSIZE
      WRITE(LFNO,701) J,LABELS(J)(1:1),LABELS(J)(2:2),(A(J,K),K=KA,KB)
  701  FORMAT(1X,I2,2X,2A4,2X,8F14.3)
      KA=KB+1
  710 CONTINUE
  660 CONTINUE
C
C CALL THE AMG ROUTINE
705   CALL AMG(A,MSIZE,NR,V1,V2,DUMMYV,LABELS)
    1 CONTINUE
C    *******************************************************************
C         END OF Galileo FILE
C    *******************************************************************
C
      RETURN
C     DEBUG SUBCHK
      END
c
c
      SUBROUTINE GET(SET,XDM,BUF)
      REAL BUF(40,40)
      INTEGER XDM,SET,XSET
      XSET=SET
C
C IN THIS VERSION, THE XDM (SIZE OF BUF) PARAMETER IS NOT USED
      READ(8,REC=XSET)BUF
      RETURN
C     DEBUG SUBCHK
      END
c
c
      SUBROUTINE PUT(SET,XDM,BUF)
      REAL BUF(40,40)
      INTEGER  XDM,SET,XSET
      XSET=SET
      WRITE(8,REC=XSET)BUF
      RETURN
C     DEBUG SUBCHK
      END

      SUBROUTINE LABMAK(N,I,J,K,L,LAB)
      CHARACTER*1 LAB(11),BLNK,DASH
      INTEGER FR,ST(4),WDS(4)
      DATA DASH/'-'/,BLNK/' '/
      DATA ST/1,4,7,10/
      WDS(1)=I
      WDS(2)=J
      WDS(3)=K
      WDS(4)=L
C CRUDE, BUT EFFECTIVE
C
      IF(N.EQ.4)GO TO 1
C FILL IN THE REMAINING SPACE IN LABL
      FR=N*3
      DO 2 M=FR,11
      LAB(M)=BLNK
2     CONTINUE
      GO TO 4
C
1     FR=9
4     DO 3 M=3,FR,3
      LAB(M)=DASH
3     CONTINUE
C
      DO 5 M=1,N
      CALL NMBR(LAB,ST(M),WDS(M))
5     CONTINUE
      RETURN
C     DEBUG SUBCHK
      END
c  February 24, 2013 I try to eliminate the block data section, since FORTRAN doesn't support it anymore...

cc
c      subroutine datwrt(prog,vers)
c
c     Scott Danielsen
c     11/27/89
c
c      character*(*) prog,vers
c      integer  hour,minute,second,hund,year,month,day
c      call getdat(year,month,day)
c      call gettim(hour,minute,second,hund)
c      year = year-1900
c      write(6,100)prog,vers,month,day,year,hour,minute,second
c 100  format('0',5x,a10,5x,a5,
c     +15x,i2.2,'/'i2.2,'/',i2.2,6x,i2.2,':'i2.2,':',i2.2)
c      return
c      end
c
      subroutine bess2(lab,pct,rlft,n1,n2,n3,n4)
      common/besmes/cons,rleft,best2,labls2     ! moved rleft, cons Feb. 24, 2013
      character*11 labls2(10)
      character*1 lab(11)
      integer cons(10,4)
      real best2(10),rleft(10)
c
      pct=abs(pct)
      do 10 j = 1,9
      if(pct .le. best2(j))then
        do 9 i = 10,j+1,-1
          best2(i)=best2(i-1)
          labls2(i)=labls2(i-1)
          cons(i,1)=cons(i-1,1)
          cons(i,2)=cons(i-1,2)
          cons(i,3)=cons(i-1,3)
          cons(i,4)=cons(i-1,4)
  9       rleft(i)=rleft(i-1)
c
          best2(j)=abs(pct)
          rleft(j)=rlft
          do 11 jj=1,11
   11     labls2(j)(jj:jj)=lab(jj)
          cons(j,1)=n1
          cons(j,2)=n2
          cons(j,3)=n3
          cons(j,4)=n4
        return
      endif
   10 continue
      return
      end
       subroutine prntcon(ncc,nunit)
       CHARACTER*1 cc,esc
c
c      this will send a control code to the printer with
c      esc before it.  Based on simple ASCII control codes
c      should work with any printer (ha ha).
c
       esc=char(27)
       cc=char(ncc)
       write(nunit,313)esc,cc
  313 format(2A1)
      return
      end
      
      subroutine help
      character*80 text
      
      open(unit=19,file='/Applications/galileo/help/stream.txt',err=2)
      do 1, i=1, 1000
      read(19,4,end=5)text
      write(6,4)text
1		continue
4 		format(a80) 
3		go to 5
2		print*,' Sorry, the help file is missing -- you''re on your own.'
5		close(19)
		return
		end
		     
    
      